" ============================================================================
" This .vimrc is based on the .vimrc by bootleq - http://bootleq.blogspot.com/
"
" Maintainer: tonny
" Mail: tonny0228@gmail.com
" Version: 2.0
" Last Change: 23/09/11 19:32:42
"
" ============================================================================


" {{{1 ================================Startup================================

if has('vim_starting')
  set all&
  set nocompatible

  mapclear
  mapclear!
endif

augroup my_vimrc
  autocmd!
augroup END

let &termencoding = &encoding
set encoding=utf-8
set fileencodings=ucs-bom,utf-8,gb18030,cp936,big5,euc-jp,euc-kr,latin1

language en_US.UTF-8
language messages POSIX

let s:is_linux=has('unix') || (executable('uname') && system('uname')=~? '^Linux')
let s:is_mac=has('macunix') || (executable('uname') && system('uname')=~? '^darwin')
let s:is_win=has('win32') || has('win64')

if s:is_linux == 'linux' | set shell=/bin/bash | endif

" 1}}}


" {{{1 ============================Plugin Bundles=============================

" {{{2 =================================Setup=================================

filetype plugin indent on

if has('vim_starting')
  if has("gui_win32")
    if isdirectory(fnamemodify('c:\cygwin\home\admin\.vim', ':p'))
      let s:rtp = 'c:\cygwin\home\admin\.vim'
    else
      " g:win32_gvim_rtp should be set by gvimrc
      if exists('g:win32_gvim_rtp') && isdirectory(fnamemodify(g:win32_gvim_rtp, ':p'))
        let s:rtp = g:win32_gvim_rtp
      else
        echoerr "You must set runtimepath (for plugin bundling) manually."
        finish
      endif
    endif
  elseif expand("<sfile>") == '/etc/users/tonny/.vimrc'
        \  && substitute(system("whoami"), '\n$', '', '') != 'tonny'
        \  && !exists("g:did_tonny_runtime")
    let g:did_tonny_runtime = 1
    let s:rtp = "/etc/users/tonny/.vim"
  elseif expand("<sfile>") == '/tmp/vimrc_human/tonny/.vimrc'
        \  && !exists("g:did_vimrc_human_runtime")
    let g:did_vimrc_human_runtime = 1
    let s:rtp = "/tmp/vimrc_human/tonny/.vim"
  else
    let s:rtp = "~/.vim"
  endif

  if !isdirectory(fnamemodify(s:rtp, ':p'))
    try
      call mkdir(fnamemodify(s:rtp, ':p'), "p")
    catch /^Vim\%((\a\+)\)\=:E739/
      echoerr "Error detected while processing: " . v:throwpoint . ":\n  " . v:exception .
            \  "\nCan't make runtime directory. Skipped sourcing vimrc.\n"
      finish
    endtry
  endif

  execute "set runtimepath+=" . fnamemodify(s:rtp, ':p') . "bundle/neobundle.vim"
  try
    call neobundle#rc(fnamemodify(s:rtp, ':p') . "bundle")
  catch /^Vim\%((\a\+)\)\=:E117/
    echoerr "Error detected while processing: " . v:throwpoint . ":\n  " . v:exception .
          \ "\n\nNo 'Bundle plugin' installed for this vimrc. Skipped sourcing plugins." .
          \ "\n\nTo install one:\n  " .
          \ "git clone git://github.com/Shougo/neobundle.vim.git " . fnamemodify(s:rtp, ":p") . "bundle/neobundle.vim\n"
    finish
  endtry
endif

filetype off

set runtimepath-=~/.vim

" 2}}} =============================Bundles============================== {{{2

let s:bundles = [
      \   ['Shougo/neobundle.vim'],
      \   ['bootleq/vim-color-bootleg'],
      \   ['taglist.vim'],
      \   ['Shougo/neocomplcache'],
      \   ['Shougo/neosnippet'],
      \   ['h1mesuke/vim-alignta'],
      \   ['Indent-Guides'],
      \   ['majutsushi/tagbar'],
      \   ['bootleq/gsession.vim'],
      \   ['bootleq/ShowMarks', {":prefer_local": 1}],
      \   ['kana/vim-surround'],
      \   ['wokmarks.vim'],
      \   ['bootleq/tcomment_vim'],
      \   ['bootleq/camelcasemotion'],
      \   ['Lokaltog/vim-easymotion'],
      \   ['chrisbra/histwin.vim'],
      \   ['bootleq/vim-cycle', {":prefer_local": 1}],
      \   ['Raimondi/delimitMate'],
      \   ['bootleq/vim-ref-bingzh', {":prefer_local": 1}],
      \   ['thinca/vim-ref'],
      \   ['mattn/webapi-vim'],
      \   ['mattn/wwwrenderer-vim'],
      \   ['tyru/open-browser.vim'],
      \   ['bootleq/LargeFile', {":prefer_local": 1}],
      \   ['Lokaltog/powerline'],
      \   ['Shougo/unite.vim'],
      \ ]
" let s:bundles = [
"       \   ['Shougo/neobundle.vim'],
"       \   ['L9'],
"       \ ]
" let s:bundles += [
"       \   ['FuzzyFinder'],
"       \   ['kana/vim-smartinput'],
"       \   ['kana/vim-surround'],
"       \   ['kana/vim-repeat'],
"       \   ['h1mesuke/vim-alignta'],
"       \   ['Shougo/neocomplcache'],
"       \   ['Shougo/neocomplcache-snippets-complete', {":prefer_local": 1}],
"       \   ['Shougo/vimfiler', {":skip": 1}],
"       \   ['thinca/vim-prettyprint'],
"       \   ['mojako/ref-sources.vim'],
"       \   ['bootleq/vim-ref-bingzh', {":prefer_local": 1}],
"       \   ['tpope/vim-rails'],
"       \   ['tpope/vim-fugitive'],
"       \   ['mattn/webapi-vim'],
"       \   ['mattn/wwwrenderer-vim'],
"       \   ['thinca/vim-ref'],
"       \   ['tyru/open-browser.vim'],
"       \   ['wokmarks.vim'],
"       \   ['bootleq/ShowMarks', {":prefer_local": 1}],
"       \   ['bootleq/camelcasemotion'],
"       \   ['bootleq/gsession.vim'],
"       \   ['bootleq/tcomment_vim'],
"       \   ['bootleq/vim-color-bootleg'],
"       \   ['bootleq/vim-cycle', {":prefer_local": 1}],
"       \   ['bootleq/vim-gitdiffall', {":prefer_local": 1}],
"       \   ['Indent-Guides'],
"       \   ['Lokaltog/vim-easymotion'],
"       \   ['netrw.vim'],
"       \   ['bootleq/LargeFile', {":prefer_local": 1}],
"       \   ['VisIncr'],
"       \   ['taglist.vim'],
"       \   ['majutsushi/tagbar'],
"       \ ]
" filetype {{{3
" let s:bundles += [
"       \   ['bootleq/JavaScript-syntax'],
"       \   ['JSON.vim'],
"       \   ['depuracao/vim-rdoc'],
"       \   ['git://github.com/jiangmiao/simple-javascript-indenter.git'],
"       \   ['hail2u/vim-css3-syntax'],
"       \   ['httplog'],
"       \   ['nginx.vim'],
"       \   ['othree/html5.vim'],
"       \   ['plasticboy/vim-markdown'],
"       \   ['timcharper/textile.vim'],
"       \   ['tpope/vim-haml'],
"       \   ['vim-ruby/vim-ruby'],
"       \ ]
" }}}3 text-obj-user {{{3
" let s:bundles += [
"       \   ['kana/vim-textobj-user'],
"       \   ['kana/vim-textobj-diff'],
"       \   ['kana/vim-textobj-fold'],
"       \   ['kana/vim-textobj-indent'],
"       \   ['kana/vim-textobj-line'],
"       \   ['nelstrom/vim-textobj-rubyblock'],
"       \   ['bootleq/vim-textobj-rubysymbol'],
"       \ ]
" }}}3 operator-user {{{3
" let s:bundles += [
"       \   ['kana/vim-operator-user'],
"       \   ['kana/vim-operator-replace'],
"       \   ['tyru/operator-html-escape.vim'],
"       \ ]
" }}}3 gf-user {{{3
" let s:bundles += [
"       \   ['kana/vim-gf-user', {":skip": 0}],
"       \ ]
" }}}3 unite {{{3
" let s:bundles += [
"       \   ['Shougo/unite.vim'],
"       \   ['h1mesuke/unite-outline'],
"       \   ['tacroe/unite-mark'],
"       \   ['thinca/vim-poslist'],
"       \   ['thinca/vim-unite-history'],
"       \   ['tsukkee/unite-help'],
"       \   ['ujihisa/unite-gem'],
"       \ ]
" }}}3 unused {{{3
" let s:bundles += [
"       \   ['gregsexton/gitv'],
"       \   ['mrkn256.vim'],
"       \   ['chrisbra/histwin.vim'],
"       \   ['Raimondi/delimitMate'],
"       \   ['tyru/restart.vim'],
"       \   ['tpope/vim-speeddating'],
"       \   ['sjl/threesome.vim'],
"       \   ['thinca/vim-ambicmd'],
"       \   ['kana/vim-altercmd'],
"       \   ['kana/vim-fakeclip'],
"       \   ['kana/vim-grex'],
"       \   ['CountJump'],
"       \   ['AndrewRadev/splitjoin.vim'],
"       \   ['Shougo/vimshell'],
"       \   ['kana/vim-smartword'],
"       \ ]
" }}}3

for bundle in s:bundles
  let s:tmp_options = get(bundle, 1, {})

  if get(s:tmp_options, ":skip")
    continue
  elseif get(s:tmp_options, ":prefer_local")
    if isdirectory(fnamemodify(s:rtp . '/repository/' . split(bundle[0], '/')[-1], ':p'))
      let s:tmp_options = {"base": s:rtp . '/repository', "type": "nosync"}
    endif
  endif

  call filter(s:tmp_options, "v:key[0] != ':'")
  execute "NeoBundle " . string(bundle[0]) . (empty(s:tmp_options) ? '' : ', ' . string(s:tmp_options))
endfor
unlet! s:bundles s:tmp_options

" 2}}} ==============================Finish============================== {{{2

filetype plugin indent on

" 2}}}

" 1}}}


" {{{1 =============================Basic Options=============================

" {{{2 =============================File Formats==============================

set fileformats=unix,mac

set nostartofline
set noendofline

" 2}}} ===============================GUI================================ {{{2

set helplang=cn

if has("gui_running")
  set antialias=true
  source $VIMRUNTIME/delmenu.vim
  set langmenu=en_US.UTF-8
  source $VIMRUNTIME/menu.vim

  set guioptions=gri
  let did_install_default_menus = 1
  let did_install_syntax_menu = 1
  let do_syntax_sel_menu = 1
  let no_buffers_menu = 1
  let bmenu_max_pathlen = 50

  highlight normal guibg=#294d4a
  highlight cursorline guibg=#333333
  highlight CursorColumn guibg=#333333

  set fileformats+=dos

  if has("gui_win32")
    set guifont=Consolas:h11,\ Monaco:h10
    set guifontwide=Consolas:h11

    set winaltkeys=no
  else
    " set guifont=Consolas\ 14
    " set guifont=Monospace\ 12
    " set guifontwide=ÊñáÊ≥âÈ©õÁ≠âÂØ¨ÂæÆÁ±≥Èªë\ 12
    " set guifontwide=AR\ PL\ UMing\ TW\ MBE\ 12
    " set guifont=Bitstream_Vera_Sans_Mono:h10:cANSI
    set guifont=Bitstream\ Vera\ Sans\ Mono\ for\ Powerline:h14
    set guifontwide=ÂπºÂúÜ:h10.5:cGB2312
  endif
endif

" 2}}} ==============================Memory============================== {{{2

set history=666

set viminfo=!,'20,<1000,:20,s100,n~/.viminfo
set viewoptions=folds,cursor

set updatetime=10000
set updatecount=0
set noswapfile
set directory=./.swp,~/.swap,.

set nobackup
set backupext=.bak
set backupdir=./.backup,~/.backup,.
set backupskip=/tmp/*,$TMPDIR/*,$TMP/*,$TEMP/*,~/workspace/*
set patchmode=.org
set nowritebackup

" 2}}} =============================Terminal============================= {{{2

if &term =~ "xterm"
  set t_#4=[D
  set t_%i=[C
  set t_Co=256

  if $OSTYPE == 'cygwin'
    let &t_ti.="\e[1 q"
    let &t_SI.="\e[5 q"
    let &t_EI.="\e[1 q"
    let &t_te.="\e[0 q"
  endif
endif

" 2}}} ===========================Composition============================ {{{2

set noexpandtab tabstop=8 softtabstop=4 smarttab
set shiftwidth=4 autoindent smartindent shiftround
set cinkeys-=:
set cinoptions+=(0
set textwidth=78
setlocal formatoptions=roql2m
if &foldmethod == 'manual'
  set foldmethod=marker
endif

" 2}}} =============================Editing============================== {{{2

set mouse=nvi
set virtualedit=block
set clipboard=autoselect,exclude:cons\|linux
set tildeop
set backspace=eol,start,indent
set whichwrap+=<,>,h,l
set nojoinspaces
set nrformats=hex
set hidden
set autoread

set scrolloff=7
set sidescrolloff=40
set sidescroll=1
set scrollopt=ver,hor,jump

set timeoutlen=500

" 2}}} =============================Display============================== {{{2

set cursorline
set nonumber
set hlsearch
nohlsearch
set ruler
set showcmd
set cmdheight=2
set shortmess+=I
set wrap
set linebreak
set showbreak=->
set nolazyredraw
set display=lastline
set listchars=nbsp:¬¨,tab:¬∑¬∑,precedes:¬´,extends:¬ª,eol:<,trail:ƒÅ
set background=dark
" set ambiwidth=double

syntax on
syntax match English /[!-~]/ contains=@spell
syntax match Normal /[^!-~]/ contains=@nospell

highlight NonText    ctermfg=247 guifg=#a73111 cterm=bold gui=bold
highlight SpecialKey ctermfg=77  guifg=#654321

set noerrorbells
set novisualbell
set t_vb=

if !exists('g:colors_name')
  set background=dark
  colorscheme bootleg
endif

set title titlestring=%t%(\ %M%)%(\ (%{expand(\"%:~:.:h\")})%)%(\ %a%)
set statusline=%2*%n%m%r%h%w%*\ %F\ %1*[FORMAT=%2*%{&ff}:%{&fenc!=''?&fenc:&enc}%1*]\ [TYPE=%2*%Y%1*]\ [COL=%2*%03v%1*]\ [ROW=%2*%03l%1*/%3*%L(%p%%)%1*]
set laststatus=2
if has('gui_running')
  set guitablabel=%t
else
  set tabline=%!SetTabLine()
endif
set showtabline=2

" 2}}} ==============================Search============================== {{{2

if $OSTYPE == 'cygwin'
  " set cdpath+=/cygdrive/g/web/
  " set path+=/home/www/
elseif $OSTYPE == 'linux-gnu'
  set cdpath+=~/workspace/
  set path+=~/workspace/
endif

" set autochdir
set ignorecase
set smartcase
set incsearch
set wrapscan
set magic
set showmatch
set matchpairs+=<:>
" set includeexpr=substitute(v:fname,'\\.','/','g')

" 2}}} ==========================Auto-Complete=========================== {{{2

set omnifunc=syntaxcomplete#Complete
set pumheight=20
set menuitems=35
set completeopt=longest,menu
set complete+=U

set wildmenu
set wildmode=longest:full,full
set wildoptions=tagfile
set wildignore+=*.o,*.a,*.so,*.obj,*.exe,*.lib,*.ncb,*.opt,*.plg,.svn,.git

" 2}}} =========================Multi-File Edit========================== {{{2

set splitbelow
set splitright
set noequalalways
set previewheight=9
set switchbuf=useopen,usetab,newtab
set tabpagemax=80
set diffopt+=vertical,context:4,foldcolumn:1

" 2}}} =========================VIM 7.3 Support========================== {{{2

if version >= 703
  set conceallevel=1
  set concealcursor=nc

  set colorcolumn=+1

  set undofile
  set undolevels=1000
  set undoreload=10000
  set undodir=~/.vim/undofiles
  if !isdirectory(&undodir)
    call mkdir(&undodir, "p")
  endif

  map  <C-ScrollWheelDown> <ScrollWheelRight>
  map  <C-ScrollWheelUp>   <ScrollWheelLeft>
  imap <C-ScrollWheelDown> <ScrollWheelRight>
  imap <C-ScrollWheelUp>   <ScrollWheelLeft>
endif

" 2}}}

" 1}}}


" {{{1 ===============================Mappings================================

let maplocalleader = ","

noremap  <Leader><LocalLeader> <LocalLeader>
noremap! <Leader><LocalLeader> <LocalLeader>
noremap  <LocalLeader>, <C-\><C-N>
noremap! <LocalLeader>, <C-\><C-N>
snoremap <LocalLeader>, <C-\><C-N>

" 2}}} ===============================Move=============================== {{{2

" noremap <expr> <Space>  repeat('<ScrollWheelDown>', 2)
" nnoremap <expr> <LocalLeader><Space> repeat('<ScrollWheelUp>', 2)
nnoremap <expr> <Space>  <SID>scroll_down()
nnoremap <expr> <LocalLeader><Space> <SID>scroll_up()
xnoremap <expr> <Space>  <SID>scroll_down('v')
xnoremap <expr> <LocalLeader><Space> <SID>scroll_up('v')

for map_mode in ['n', 'o', 'x']
  execute map_mode . "noremap j gj"
  execute map_mode . "noremap k gk"
  execute map_mode . "noremap gj j"
  execute map_mode . "noremap gk k"
endfor

inoremap <expr> <Down> pumvisible() ? "\<C-N>" : "\<C-O>gj"
inoremap <expr> <Up> pumvisible() ? "\<C-P>" : "\<C-O>gk"

nmap <silent><Home> :call SmartHome("n")<CR>
nmap <silent><End> :call SmartEnd("n")<CR>
imap <silent><Home> <C-R>=SmartHome("i")<CR>
imap <silent><End> <C-R>=SmartEnd("i")<CR>
vmap <silent><Home> <Esc>:call SmartHome("v")<CR>
vmap <silent><End> <Esc>:call SmartEnd("v")<CR>

map  <kHome> <Home>
map! <kHome> <Home>
map  <kEnd>  <End>
map! <kEnd>  <End>

nnoremap ' `
nnoremap 0 ^

cnoremap <C-A> <Home>
cnoremap <C-E> <End>
cnoremap <C-B> <Left>
cnoremap <C-F> <Right>

nmap <LocalLeader>w <C-W>
nnoremap <C-W>gf :tab wincmd f<CR>
nnoremap <C-W>V :wincmd K <Bar> wincmd =<CR>
nnoremap <LocalLeader>gf :tab wincmd f<CR>
nnoremap <expr> <CR> &modifiable ? "i<CR><C-\><C-N>" : "<C-]>"
nnoremap <expr> <BS> &modifiable ? "i<C-W><C-\><C-N>" : "<C-O>"

nnoremap gr gT
nnoremap <silent> gT :tablast<CR>
nnoremap <silent> gR :tabfirst<CR>
nnoremap <silent> <expr> <LocalLeader>gt printf(":tabmove %s<CR>", tabpagenr() == tabpagenr('$') ? 0 : tabpagenr())
nnoremap <silent> <expr> <LocalLeader>gr printf(":tabmove %s<CR>", tabpagenr() == 1 ? '' : tabpagenr() - 2)
nnoremap <silent> <LocalLeader>gT :tabmove<CR>
nnoremap <silent> <LocalLeader>gR :tabmove 0<CR>

" 2}}} ===============================Edit=============================== {{{2

nmap <C-H> <BS>

nnoremap p ]p
nnoremap Y y$

nnoremap vaa ggVG
nnoremap <LocalLeader>gv V`]

nnoremap <LocalLeader>< i0<C-D><C-\><C-N>
inoremap <LocalLeader>< 0<C-D>
xnoremap <LocalLeader>< 99<

inoremap <C-Z> <C-O>u
inoremap <C-W> <C-G>u<C-W>
inoremap <expr> <C-U> (pumvisible() ? "\<C-E>" : '') . "\<C-G>u\<C-U>"

inoremap <LocalLeader>o <C-O>

noremap <silent> <C-S> :update<CR>
inoremap <silent> <C-S> <C-\><C-N>:update<CR>
xnoremap <silent> <C-S> <C-\><C-N>:update<CR>

noremap <C-Del> :quit<CR>
noremap <C-kDel> :quit<CR>
map <kDel> <Del>

if s:is_win == 'win'
  map <leader>ee :call SwitchToBuf("~/_vimrc")<CR>
  autocmd! bufwritepost ~/_vimrc source ~/_vimrc

  nnoremap <LocalLeader>ec :tabnew $TEMP/scratch.txt<CR>
  nnoremap <LocalLeader>q :e $TEMP/buffer<CR>
else
  map <leader>ee :call SwitchToBuf("~/.vimrc")<cr>
  autocmd! bufwritepost ~/.vimrc source ~/.vimrc

  nnoremap <LocalLeader>ec :tabnew /tmp/scratch.txt<CR>
  nnoremap <LocalLeader>q :e /tmp/buffer<CR>
endif

nnoremap ; :
cnoremap <LocalLeader>d <C-\>e getcmdpos() == 1 ? '' : getcmdline()[:getcmdpos()-2]<CR>

cnoremap <C-D> <Del>
cnoremap <C-K> <C-U>

autocmd FileType qf nnoremap <buffer> <CR> <CR>

" 2}}} ===========================Function Key=========================== {{{2

map  <F1> :help <C-R>=expand('<cword>')<CR><CR>
map  <LocalLeader><F1> :tab help <C-R>=expand('<cword>')<CR><CR>
xmap <F1> :<C-U>call SaveReg()<CR>gvy:let b:tempReg=@"<CR>:call RestoreReg()<CR>:help <C-R>=b:tempReg<CR><CR>
xmap <LocalLeader><F1> :<C-U>call SaveReg()<CR>gvy:let b:tempReg=@"<CR>:call RestoreReg()<CR>:help <C-R>=b:tempReg<CR><CR>

nmap <F2> :%s/<C-R><C-W>
xmap <F2> :<C-U>call SaveReg()<CR>gvy:let b:tempReg=@"<CR>:call RestoreReg()<CR>gv:<C-U>%s/ <C-R>=b:tempReg<CR>

noremap <silent> <F3> :nohlsearch<CR>
inoremap <silent> <F3> <C-O>:nohlsearch<CR>
noremap <silent> <F4> :set hlsearch<CR>
inoremap <silent> <F4> <C-O>:set hlsearch<CR>

nnoremap <F5> :call SynStackInfo()<CR>
nnoremap <Leader><F5> :tabdo e!<CR>
nnoremap <F6> :QuickOff<CR>

nnoremap <silent><F8> :setlocal spell! spelllang=en_us spell?<CR>
xnoremap <silent><F8> :<C-U>setlocal spell! spelllang=en_us spell?<CR>gv
inoremap <silent><F8> <C-O>:setlocal spell! spelllang=en_us spell?<CR>

set pastetoggle=<F11>
map  <silent> <F12> :set list!<CR>
imap <silent> <F12> <C-O>:set list!<CR>

" 2}}} ==========================Auto-Complete=========================== {{{2

cnoremap <LocalLeader>. <C-E>
cnoremap <LocalLeader><CR> <C-E>

cnoremap <C-P> <Up>
cnoremap <C-N> <Down>

inoremap <LocalLeader>. <C-X><C-O>
inoremap <expr> <C-J> pumvisible() ? "\<C-N>" : "\<C-J>"
inoremap <expr> <C-K> pumvisible() ? "\<C-P>" : "\<C-K>"

" 2}}} ============================Clipboard============================= {{{2

nmap <Leader>xp :r $HOME/.vimxfer<CR>
nmap <Leader>xy V:w! $HOME/.vimxfer<CR>
vmap <Leader>xy :w! $HOME/.vimxfer<CR>
vmap <Leader>xa :w>> $HOME/.vimxfer<CR>

" 2}}} =============================Quickfix============================= {{{2

nmap q [quickfix]
nmap [quickfix]w [localist]
nnoremap [quickfix] <Nop>
nnoremap [localist] <Nop>
nnoremap Q q

" {{{3 =============================Quickfix List=============================

nnoremap <silent> [quickfix]j :cnext<CR>
nnoremap <silent> [quickfix]k :cprevious<CR>
nnoremap <silent> [quickfix]r :crewind<CR>
nnoremap <silent> [quickfix]K :cfirst<CR>
nnoremap <silent> [quickfix]J :clast<CR>
nnoremap <silent> [quickfix]l :clist<CR>
nnoremap <silent> [quickfix]o :copen<CR>
nnoremap <silent> [quickfix]c :cclose<CR>
nnoremap <silent> [quickfix]p :colder<CR>
nnoremap <silent> [quickfix]n :cnewer<CR>

" 3}}} ==========================Location List=========================== {{{3

nnoremap <silent> [localist]j :lnext<CR>
nnoremap <silent> [localist]k :lprevious<CR>
nnoremap <silent> [localist]r :lrewind<CR>
nnoremap <silent> [localist]K :lfirst<CR>
nnoremap <silent> [localist]J :llast<CR>
nnoremap <silent> [localist]l :llist<CR>
nnoremap <silent> [localist]o :lopen<CR>
nnoremap <silent> [localist]c :lclose<CR>
nnoremap <silent> [localist]p :lolder<CR>
nnoremap <silent> [localist]n :lnewer<CR>

" 3}}}

" 2}}} ===========================Text Objects=========================== {{{2

let g:textobj_rubyblock_no_default_key_mappings = 1
function! s:textobj_rubyblock_settings()
  xmap <buffer> ab <Plug>(textobj-rubyblock-a)
  omap <buffer> ab <Plug>(textobj-rubyblock-a)
  xmap <buffer> ib <Plug>(textobj-rubyblock-i)
  omap <buffer> ib <Plug>(textobj-rubyblock-i)
endfunction

autocmd! my_vimrc FileType ruby call s:textobj_rubyblock_settings()

" 2}}} ============================Operators============================= {{{2

nmap <LocalLeader>r <Plug>(operator-replace)
xmap <LocalLeader>r <Plug>(operator-replace)
nmap <LocalLeader>R <Plug>(operator-replace)$
xmap <LocalLeader>R <Plug>(operator-replace)$
nmap <LocalLeader>he <Plug>(operator-html-escape)
xmap <LocalLeader>he <Plug>(operator-html-escape)
nmap <LocalLeader>hd <Plug>(operator-html-unescape)
xmap <LocalLeader>hd <Plug>(operator-html-unescape)

" 2}}} ===============================w!!================================ {{{2

cnoremap <expr> w!! ((getcmdtype() == ':' && getcmdpos() <= 1) ? 'call SudoWrite()'  : 'w!!')

" 2}}} ==============================Others============================== {{{2

nmap ZZ <Nop>
nmap ZQ <Nop>

" 2}}}

" 1}}}


" {{{1 ===============================Commands================================

if executable('cat')
  command! EmptyFile call system("cat /dev/null > " . shellescape(expand('%:p'))) | checktime
endif
command! -nargs=1 -bang -complete=file Rename saveas<bang> <args> | call delete(expand('#'))

" command! Rnginx execute "!sudo\ service nginx restart"
" command! Rtouch execute "!touch tmp/restart.txt"

command! -bar -complete=file -nargs=+ Grep call s:grep('grep', [<f-args>])
command! -bar -complete=file -nargs=+ Lgrep call s:grep('lgrep', [<f-args>])

" call altercmd#load()
" call altercmd#define('<buffer>', 'help?', 'HelpForWhat')
" command! HelpForWhat echoerr "Sure.  Is this help you?"

" 1}}}


" {{{1 =============================Abbreviations=============================

cnoreabbrev <expr> t ((getcmdtype() == ':' && getcmdpos() <= 2) ? 'tabnew' : 't')
cnoreabbrev <expr> m ((getcmdtype() == ':' && getcmdpos() <= 2) ? 'messages' : 'm')
cnoreabbrev <expr> g ((getcmdtype() == ':' && getcmdpos() <= 2) ? 'GitDiff' : 'g')
cnoreabbrev <expr> u ((getcmdtype() == ':' && getcmdpos() <= 2) ? 'Unite' : 'u')
cnoreabbrev <expr> f ((getcmdtype() == ':' && getcmdpos() <= 2) ? 'VimFilerSplit -buffer-name=' : 'f')
cnoreabbrev <expr> tm ((getcmdtype() == ':' && getcmdpos() <= 3) ? 'TabMessage' : 'tm')
cnoreabbrev <expr> tms ((getcmdtype() == ':' && getcmdpos() <= 4) ? 'TabMessage scriptnames' : 'tms')
cnoreabbrev <expr> '<,'>q ((getcmdtype() == ':' && getcmdpos() <= 7) ? 'q' : "'<,'>q")
" cnoreabbrev <expr> re ((getcmdtype() == ':' && getcmdpos() <= 3) ? 'CleanMakeGSession<CR>:qa' : 're')
cnoreabbrev ll <lt>LocalLeader>
inoreabbrev ll <lt>LocalLeader>

iabbrev xdate <c-r>=strftime("%d/%m/%y %H:%M:%S")<cr>

" 1}}}


" {{{1 ================================Cscope=================================

if has("cscope") && filereadable("/usr/bin/cscope")
  set cscopeprg=/usr/bin/cscope
  set cscopetag
  set cscopetagorder=0
  set cscopeverbose
  set cscopequickfix=s-,c-,d-,i-,t-,e-

  if filereadable("cscope.out")
    silent cscope add cscope.out
  elseif $CSCOPE_DB != ""
    silent cscope add $CSCOPE_DB
  endif

  let s:outFiles = [
      \   '/home/tonny/workspace/cscope.out',
      \ ]
  for outFile in s:outFiles
    if filereadable(outFile)
      try
        silent execute 'cscope add ' . expand(outFile)
      catch /^Vim(cscope):E568:/
      endtry
    endif
  endfor
endif

nnoremap <silent> <leader>css :cs find s <C-R>=expand("<cword>")<CR><CR>
nnoremap <silent> <leader>csg :cs find g <C-R>=expand("<cword>")<CR><CR>
nnoremap <silent> <leader>csc :cs find c <C-R>=expand("<cword>")<CR><CR>
nnoremap <silent> <leader>cst :cs find t <C-R>=expand("<cword>")<CR><CR>
nnoremap <silent> <leader>cse :cs find e <C-R>=expand("<cword>")<CR><CR>
nnoremap <silent> <leader>csf :cs find f <C-R>=expand("<cfile>")<CR><CR>
nnoremap <silent> <leader>csi :cs find i <C-R>=expand("<cfile>")<CR>$<CR>
nnoremap <silent> <leader>csd :cs find d <C-R>=expand("<cword>")<CR><CR>

" 1}}}


" {{{1 =================================Ctags=================================

" let tlist_html_settings   = 'html;h:Headers;o:IDs;c:Classes'
" let tlist_xhtml_settings   = 'html;h:Headers;o:IDs;c:Classes'
" let tlist_php_settings   = 'html;h:Headers;o:IDs;c:Classes'
" let tlist_javascript_settings = 'js;f:Functions;c:Classes;o:Objects'
" let tlist_javascript_settings = 'javascript;f:Functions;c:Classes;o:Objects'
" let tlist_css_settings = 'css;c:Classes;o:Objects(ID);t:Tags(Elements)'

set tags+=../c.tags,./c.tags,./*/c.tags,../cpp.tags,./cpp.tags,./*/cpp.tags,../java.tags,./java.tags,./*/java.tags,../sh.tags,./sh.tags,./*/sh.tags,../vim.tags,./vim.tags,./*/vim.tags
" if has("gui_running")
"   noremap <silent> <M-z> :TlistToggle<CR>
" else
"   noremap <silent> z :TlistToggle<CR>
" endif

" 1}}}


" {{{1 =================================Tmux==================================

if &term =~ "xterm" && exists('$TMUX')
  let &t_ti = &t_ti . "\e[?2004h"
  let &t_te = "\e[?2004l" . &t_te
  let &pastetoggle = "\e[201~"

  map <special> <expr> <Esc>[200~ XTermPasteBegin("i")
  imap <special> <expr> <Esc>[200~ XTermPasteBegin("")
  cmap <special> <Esc>[200~ <nop>
  cmap <special> <Esc>[201~ <nop>

  map <F11> <Esc>[201~
  imap <F11> <Esc>[201~
endif

" 1}}}


" {{{1 ================================Plugins================================

runtime! ftplugin/man.vim
runtime! macros/matchit.vim

" {{{2 =================================Netrw=================================

" let g:netrw_ftp = 1
" let g:netrw_preview = 1
" let g:netrw_ignorenetrc = 0
" let g:netrw_ftpextracmd = 'passive'

let g:netrw_banner=0
let g:netrw_liststyle = 3
let g:netrw_winsize = 20
" let g:netrw_browsex_viewer = '-'
let g:netrw_timefmt = '%Y-%m-%d %T'
" if exists("g:qfix_win") && a:forced == 0

nmap <leader>e :Vexplore<CR>

" 2}}} ===========================FuzzyFinder============================ {{{2

noremap [fuf] <Nop>
map <LocalLeader>f [fuf]
noremap [fuf]f :FufFileWithCurrentBufferDir<CR>
noremap [fuf]r :FufMruFile<CR>
noremap [fuf]b :FufBuffer<CR>
" noremap [fuf]c :FufChangeList<CR>
noremap [fuf]t :FufBufferTagAll<CR>
noremap [fuf]h :FufHelp<CR>
noremap [fuf]q :FufQuickfix<CR>
noremap <silent> [fuf]<F5> :FufRenewCache<CR>
" nnoremap [fuf]d :FufDir<CR>
" nnoremap [fuf]m :FufBookmark<CR>
" nnoremap [fuf]d :FufBookmarkDir<CR>
noremap [fuf]p :call g:fuf_regFinder(0)<CR>
noremap [fuf]P :call g:fuf_regFinder(1)<CR>
noremap [fuf]g :call g:fuf_tabFinder()<CR>

inoremap ¬´fuf¬ª <Nop>
imap <LocalLeader>f ¬´fuf¬ª
inoremap ¬´fuf¬ªf <C-\><C-N>:FufFileWithCurrentBufferDir<CR>
inoremap ¬´fuf¬ªp <C-\><C-N>:call g:fuf_regFinder(0)<CR>
inoremap ¬´fuf¬ªP <C-\><C-N>:call g:fuf_regFinder(1)<CR>
inoremap ¬´fuf¬ªg <C-\><C-N>:call g:fuf_tabFinder()<CR>

let g:fuf_dataDir = '~/.vim/fuf-data'
let g:fuf_modesDisable = ['coveragefile', 'dir', 'line', 'bookmarkdir', 'bookmarkfile', 'mrucmd', 'jumplist', 'taggedfile', 'givenfile', 'givedir']

let g:fuf_keyOpen='<LocalLeader><CR>'
let g:fuf_keyOpenSplit=''
let g:fuf_keyOpenVsplit=''
let g:fuf_keyOpenTabpage='<CR>'
" let g:fuf_keyPreview='<Space>'
let g:fuf_buffer_keyDelete='<C-D>'
let g:fuf_keyPrevPattern = '<C-PageUp>'
let g:fuf_keyNextPattern = '<C-PageDown>'

if $OSTYPE == 'cygwin'
  let g:fuf_abbrevMap = {
        \   "^r:" : [ "/cygdrive/d/repository/" ],
        \   "^w:" : ["/cygdrive/d/web"],
        \   '^vr:' : map(filter(split(&runtimepath, ','), 'v:val !~ "after$"'), 'v:val . ''/**/'''),
        \ }
else
  let g:fuf_abbrevMap = {
        \   "^r:" : [ "~/repository/" ],
        \   "^rb:" : [ "/opt/ruby/lib/ruby/gems/1.8/gems/" ],
        \   "^w:" : [ "/home/www/" ],
        \   '^vr:' : map(filter(split(&runtimepath, ','), 'v:val !~ "after$"'), 'v:val . ''/**/'''),
        \ }
endif

let g:fuf_mrufile_maxItem = 100
let g:fuf_mrucmd_maxItem = 100
let g:fuf_maxMenuWidth = 90
let g:fuf_enumeratingLimit = 50

" After VimEnter, set bookmark-dir with command 'FufBookmarkDirAdd'.
" Also use 'FufEditDataFile'.

augroup my_vimrc
  autocmd BufEnter \[fuf\] set pumheight=0
  autocmd BufLeave \[fuf\] set pumheight=25
  autocmd FileType fuf setlocal nowrap nolist
  autocmd FileType fuf inoremap <buffer> <Tab> <C-N>
  autocmd FileType fuf inoremap <buffer> <S-Tab> <C-P>
  autocmd FileType fuf inoremap <buffer> <LocalLeader>. **/
  autocmd FileType fuf inoremap <buffer> <Space> <C-W>
augroup END

" {{{3 ===============================Registers===============================

let g:fuf_regListener = {}
let g:fuf_regListener.putBefore = 0   " 0: p, 1: P

function! g:fuf_regListener.onComplete(item, method)
  let l:regName = strpart(a:item, 1, 1)
  if a:method == 4
    silent execute 'normal! "' . l:regName . (g:fuf_regListener.putBefore ? 'P' : 'p')
  else
    execute '7new [@' . escape( l:regName, '"' ) . ']'
    setlocal noswapfile buftype=nofile bufhidden=wipe
    execute '0put=@' . l:regName
    redraw
    setlocal nomodified
  endif
endfunction

function! g:fuf_regListener.onAbort()
endfunction

function! g:fuf_regFinder(putBefore)
  let g:fuf_regListener.putBefore = a:putBefore
  redir => l:regs
  silent execute ':registers'
  redir END
  let l:regList = split(l:regs, '\n')
  let l:regList = filter(l:regList, 'v:val =~ "' . escape('\m^".\s\{3,}\S\+', '\"') . '"')  " remove non-register lines
  " let l:regList = map(l:regList, 'substitute(v:val, "\\m.\\{' . &columns . '}\\zs.*", "...", "")')  " has problem with long line
  call fuf#callbackitem#launch('', 1, 'registers>', g:fuf_regListener, l:regList, 0)
endfunction

" 3}}} ===============================Tabs=============================== {{{3

let g:fuf_tabListener = {}

function! g:fuf_tabListener.onComplete(item, method)
  let l:tabnr = matchstr(a:item, '\d\+')
  if a:method == 4
    silent execute 'normal! ' . l:tabnr . 'gt'
  else
    silent execute 'tabclose ' . l:tabnr
  endif
endfunction

function! g:fuf_tabListener.onAbort()
endfunction

function! g:fuf_tabFinder()
  if exists("s:tabLineTabs")
    let l:tabList = []
    for tab in s:tabLineTabs
      let label = tab.n . '. ' . (strlen(tab.split) > 0 ? ('(' . tab.split . ')') : '') . tab.flag . tab.filename
      if tab.n == tabpagenr()
        let label = '*' . label
      endif
      call add(l:tabList, label)
    endfor
    call fuf#callbackitem#launch('', 1, 'tabs>', g:fuf_tabListener, l:tabList, 0)
  endif
endfunction

" 3}}}

" 2}}} ===============================Unite=============================== {{{2

nnoremap [unite] <Nop>
xnoremap [unite] <Nop>
nmap <Leader>f [unite]
xmap <Leader>f [unite]

nnoremap [unite]S :<C-U>Unite source<CR>
nnoremap <silent> [unite]f :<C-U>UniteWithBufferDir -buffer-name=files -start-insert file<CR>
nnoremap <silent> [unite]r :<C-U>Unite -buffer-name=mru -start-insert file_mru<CR>
nnoremap <silent> [unite]/ :<C-U>Unite -buffer-name=search line<CR>

nnoremap <silent> [unite]d :<C-U>Unite -buffer-name=mru_dir -start-insert directory_mru<CR>
nnoremap <silent> [unite]t :<C-U>Unite -buffer-name=tabs -start-insert tab<CR>
nnoremap <silent> [unite]p :<C-U>Unite -buffer-name=registers -start-insert register<CR>
xnoremap <silent> [unite]p "_d:<C-U>Unite -buffer-name=register register<CR>
nnoremap <silent> [unite]b :<C-U>Unite -buffer-name=bookmarks bookmark<CR>
nnoremap <silent> [unite]m :<C-U>Unite mark<CR>
nnoremap <silent> [unite]h :<C-U>Unite -buffer-name=helps help<CR>
nnoremap <silent> [unite]o :<C-U>Unite outline<CR>
nnoremap <silent> [unite]q :<C-u>Unite qflist -no-quit<CR>
nnoremap <silent> [unite]s :<C-u>Unite -start-insert session<CR>
nnoremap <silent> [unite]g :<C-u>Unite tab<CR>
" nnoremap <silent> [unite]G :<C-u>Unite grep -no-quit<CR>
nnoremap <silent> [unite]j :<C-u>Unite jump<CR>
nnoremap <silent> [unite]c :<C-u>Unite change<CR>
nnoremap <silent> [unite]q :<C-u>Unite poslist<CR>

let g:unite_update_time = 70
let g:unite_enable_split_vertically = 1
let g:unite_source_file_mru_limit = 200
let g:unite_source_file_mru_time_format = "(%m/%d %T) "
let g:unite_source_file_rec_max_depth = 5

let g:unite_enable_ignore_case = 1
let g:unite_enable_smart_case = 1

let g:unite_source_session_path = expand('~/.vim/session/')

function! s:unite_settings()
  nmap <buffer> <C-J> <Plug>(unite_loop_cursor_down)
  nmap <buffer> <C-K> <Plug>(unite_loop_cursor_up)
  nmap <buffer> m <Plug>(unite_toggle_mark_current_candidate)
  nmap <buffer> M <Plug>(unite_toggle_mark_all_candidate)
  nmap <buffer> <LocalLeader><F5> <Plug>(unite_redraw)
  nmap <buffer> <LocalLeader>q <Plug>(unite_exit)

  vmap <buffer> m <Plug>(unite_toggle_mark_selected_candidates)

  imap <buffer> <C-J> <Plug>(unite_select_next_line)
  imap <buffer> <C-K> <Plug>(unite_select_previous_line)
  imap <buffer> <LocalLeader><BS> <Plug>(unite_delete_backward_path)
  imap <buffer> <LocalLeader>q <Plug>(unite_exit)
endfunction
autocmd! my_vimrc FileType unite call s:unite_settings()

" actions
" TODO secondary default action
" TODO bookmark 'rename' action
" TODO bookmark should convert slashes for different OS
" call unite#set_substitute_pattern('files', '^v/', unite#util#substitute_path_separator($HOME).'/.vim/', 1000)
" call unite#custom_default_action('file', 'tabopen')

" This is for bookmark, however, define a custom action for jump_list would be better.
" call unite#custom_default_action('directory, jump_list', 'tabopen')

" 2}}} ==========================NeoComplCache=========================== {{{2

let g:neocomplcache_enable_at_startup = 1
let g:neocomplcache_enable_smart_case = 1
let g:neocomplcache_enable_camel_case_completion = 1
let g:neocomplcache_enable_underbar_completion = 1
let g:neocomplcache_enable_auto_select = 1
let g:neocomplcache_enable_auto_delimiter = 1
let g:neocomplcache_max_list = 100

let g:neocomplcache_lock_buffer_name_pattern = '\[fuf\]'
let g:neocomplcache_temporary_dir = expand('~/.vim/.neocon')

inoremap <LocalLeader>x <C-O>:NeoComplCacheToggle<CR>
inoremap <expr><LocalLeader><C-H> neocomplcache#smart_close_popup()."\<BS>"
inoremap <expr><LocalLeader><BS> neocomplcache#smart_close_popup()."\<BS>"
inoremap <expr><C-Y> neocomplcache#close_popup()
inoremap <expr><C-E> neocomplcache#cancel_popup()

let g:neocomplcache_omni_functions = {
      \ 'python' : 'pythoncomplete#Complete',
      \ 'ruby' : 'rubycomplete#Complete',
      \ }

" {{{3 ===============================Snippets================================

let g:neocomplcache_snippets_dir = expand('~/.vim/snippets')
imap <expr><Tab> neocomplcache#sources#snippets_complete#expandable() ?
      \ "\<Plug>(neocomplcache_snippets_expand)" : pumvisible() ? "\<C-N>" : "\<Tab>"
" TODO jump back to previous placeholder
imap <expr><S-Tab> neocomplcache#sources#snippets_complete#jumpable() ?
      \ "\<Plug>(neocomplcache_snippets_jump)" : pumvisible() ? "\<C-P>" : "\<S-Tab>"
smap <Tab> <Plug>(neocomplcache_snippets_expand)

" TODO migrate all my snipMate settings
" https://github.com/bootleq/snipmate.vim/tree/master/snippets
" ~/repository/snipmate.vim
command! -bang -bar -complete=filetype -nargs=? EditSnippets call s:edit_snippets(<bang>0, [<f-args>])
function! s:edit_snippets(runtime_snippets, args) "{{{
  let l:filetype = get(a:args, 0, &l:filetype)
  if !empty(l:filetype)
    tab split
    if a:runtime_snippets
      execute "NeoComplCacheEditRuntimeSnippets " . l:filetype
    else
      execute "NeoComplCacheEditSnippets " . l:filetype
    endif
  endif
endfunction

" 3}}}

" 2}}} ============================Neosnippet============================ {{{2

imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)

imap <expr><TAB> neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : pumvisible() ? "\<C-n>" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable_or_jumpable() ? "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"

if has('conceal')
  set conceallevel=2 concealcursor=i
endif"

" let g:neosnippet#snippets_directory='~/.vim/bundle/snipmate-snippets/snippets'"

" 2}}} =============================VimFiler============================= {{{2

let g:vimfiler_as_default_explorer = 1
let g:vimfiler_edit_action = 'tabopen'
let g:vimfiler_enable_clipboard = 0
let g:vimfiler_safe_mode_by_default = 0
let g:vimfiler_time_format = '%y-%m-%d %H:%M'

if $OSTYPE == 'cygwin' || has("gui_win32")
  let g:unite_kind_file_use_trashbox = 1
  let g:vimfiler_detect_drives = [
        \ 'C:/', 'D:/', 'E:/', 'F:/', 'G:/', 'H:/', 'I:/',
        \ 'J:/', 'K:/', 'L:/', 'M:/', 'N:/']
elseif $OSTYPE == 'linux-gnu'
  let g:vimfiler_detect_drives =
        \ split(glob('/mnt/*'), '\n') + split(glob('/media/*'), '\n')
endif

autocmd my_vimrc FileType vimfiler call s:vimfiler_my_settings()
function! s:vimfiler_my_settings()
  nnoremap <silent><buffer> H <Nop>
endfunction

" 2}}} =============================Alignta============================== {{{2

let g:alignta_default_arguments = '! \S\+'
xnoremap <silent> <LocalLeader>= :Alignta! \S\+<CR>
xnoremap <silent> <LocalLeader>A :Alignta! \S\+<CR>

" 2}}} ===========================Indent Guide=========================== {{{2

let g:indent_guides_enable_on_vim_startup = 0
let g:indent_guides_auto_colors = 0
let g:indent_guides_guide_size = 1
let g:indent_guides_indent_levels = 30

" 2}}} ==============================Rails=============================== {{{2

" let g:loaded_rails = 1
let g:rails_statusline = 1
let g:rails_url = 'http://localhost/'
" set title titlestring=%t%(\ %M%)%(\ (%{expand(\"%:~:.:h\")})%)%(\ %a%)%(\ %{rails#statusline(1)})%
autocmd User Rails command! Rclearlog execute "silent Rake log:clear"

" 2}}} =============================TagList============================== {{{2

if !executable('ctags')
  let loaded_taglist = 1
endif
let Tlist_GainFocus_On_ToggleOpen = 1
let Tlist_Auto_Highlight_Tag = 0
let Tlist_Show_One_File = 1
let Tlist_File_Fold_Auto_Close = 1
" let Tlist_Sort_Type = 'name'
let Tlist_Use_Right_Window = 1
let Tlist_WinWidth = 40
let Tlist_Enable_Fold_Column = 0
"let Tlist_Show_Menu = 1

" 2}}} ==============================TagBar============================== {{{2

if !executable('ctags')
  let g:loaded_tagbar = 1
endif
let g:tagbar_autofocus = 1
let g:tagbar_width=30

if has("gui_running")
  noremap <silent> <M-z> :TagbarToggle<CR>
else
  noremap <silent> z :TagbarToggle<CR>
endif

" 2}}} =============================GSession============================= {{{2

let g:autoload_session = 1
let g:autosave_session = 0
let g:gsession_non_default_mapping = 1
let g:gsession_use_git = 1

nnoremap <silent> <leader>ss    :call MakeSessionWithSafety()<CR>
nnoremap <silent> <leader>se    :GSessionEliminateCurrent<CR>
nnoremap <silent> <leader>sn    :NamedSessionMake<CR>
nnoremap <silent> <leader>sl    :NamedSessionLoad<CR>

function! MakeSessionWithSafety()
  let prompt = 0
  if exists('b:LargeFile_store') || &undolevels < 0
    let prompt = '[LargeFile] make session anyway? (y/N) '
  else
    for tab in range(tabpagenr('$'))
      if gettabwinvar(tab + 1, 1, '&diff')
        let prompt = '[Diff mode] make session anyway? (y/N) '
        break
      elseif bufname(tabpagebuflist(tab + 1)[0]) == '.git/COMMIT_EDITMSG'
        let prompt = '[Git commit] make session anyway? (y/N)'
        break
      elseif tabpagenr() == tabpagenr('$') && tabpagenr() == 1
        let prompt = '[One tab only] make session anyway? (y/N)'
        break
      endif
    endfor
  endif

  if !empty(prompt)
    redraw | echomsg prompt | redraw
    let yes = getchar()
    if nr2char(yes) != 'y'
      echomsg 'Aborted.' | redraw
    else
      silent call StashSessionBackup(1)
      GSessionMake
    end
  else
    silent call StashSessionBackup(1)
    GSessionMake
  endif
endfunction

let g:session_back_dir = expand('~/.vim/session/backup')
if !isdirectory(g:session_back_dir)
  call mkdir(g:session_back_dir, "p")
endif

command! -nargs=0 SessionBackupSave call StashSessionBackup(1)
command! -nargs=0 SessionBackupRestore call StashSessionBackup(0)
function! StashSessionBackup(save)
  if a:save
    if filereadable(v:this_session)
      call system("cp ". v:this_session . "\ " . g:session_back_dir)
    endif
  else
    let bakfile = g:session_back_dir . '/' . fnamemodify(v:this_session, ":t")
    if filereadable(bakfile)
      call system("cp " . bakfile . "\ ~/.vim/session/")
      echomsg 'Restored session file from backup.'
      echomsg 'For clearer restoring, quit and re-enter Vim now.'
    endif
  endif
endfunction

command! -bang CleanMakeGSession call CleanMakeGSession(<bang>0)
function! CleanMakeGSession(no_quit)
  let save_ssop = &sessionoptions
  set sessionoptions-=globals
  set sessionoptions-=localoptions
  set sessionoptions-=options
  abclear
  mapclear
  mapclear!
  GSessionMake
  execute "set sessionoptions=" . save_ssop
  if !a:no_quit
    execute 'quitall'
  else
    echomsg 'For clearer saving, quit and re-enter Vim now.'
  endif
endfunction

" 2}}} ============================ShowMarks============================= {{{2

let g:showmarks_include = 'abcdefghijklmnopqrstuvwxyz' . 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
" let g:showmarks_include="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.'`^<>[]{}()\""
let g:showmarks_ignore_type = ""
" let g:showmarks_ignore_type='hqm'
let g:showmarks_textlower = "\t"
" let g:showmarks_textlower='^'
let g:showmarks_textupper = "\t"
" let g:showmarks_textupper='>'
let g:showmarks_textother = "\t"
let g:showmarks_auto_toggle = 0
let g:showmarks_no_mappings = 1
" let g:showmarks_hlline_lower=1
" let g:showmarks_hlline_upper=1

nmap mt <Plug>ShowMarksToggle

" 2}}} =====================Surround (kana version)====================== {{{2

if exists('g:loaded_surround') && exists('*SurroundRegister')
    call SurroundRegister('g', '&', "&lt;\r&gt;")
    call SurroundRegister('g', 'C', "<![CDATA[\r]]>")
    call SurroundRegister('g', 'Ôºà', "Ôºà\rÔºâ")
    call SurroundRegister('g', '„Äå', "„Äå\r„Äç")
    call SurroundRegister('g', '„Äé', "„Äé\r„Äè")
endif

nmap s  <plug>Ysurround
nmap ss <plug>Yssurround
nmap sss <Nop>

" 2}}} =============================WokMarks============================= {{{2

let g:wokmarks_do_maps = 0
let g:wokmarks_pool = "abcdefghijklmnopqrstuvwxyz"

nmap mm <Plug>ToggleMarkWok
map mj <Plug>NextMarkWok
map mk <Plug>PrevMarkWok
autocmd User WokmarksChange :ShowMarksOn

" 2}}} =============================tComment============================= {{{2

let g:tcommentMapLeader1 = ''
let g:tcommentMapLeader2 = ''
let g:tcommentMapLeaderOp1 = ''
let g:tcommentMapLeaderOp2 = ''
let g:tc_option = ' col=1'

noremap <silent> <expr> <LocalLeader>cc ":TComment " .       (exists('b:tc_option') ? b:tc_option : g:tc_option) . "<CR>"
noremap <silent> <expr> <LocalLeader>cb ":TCommentBlock " .  (exists('b:tc_option') ? b:tc_option : g:tc_option) . "<CR>"
noremap <silent> <expr> <LocalLeader>ci ":TCommentInline " . (exists('b:tc_option') ? b:tc_option : g:tc_option) . "<CR>"
noremap <silent> <expr> <LocalLeader>c$ ":TCommentRight " .  (exists('b:tc_option') ? b:tc_option : g:tc_option) . "<CR>"
map <silent><expr> <LocalLeader>ca IsInComment() ?
      \ "vac:TComment " . (exists('b:tc_option') ? b:tc_option : g:tc_option) . "<CR>" :
      \ ":TComment " . (exists('b:tc_option') ? b:tc_option : g:tc_option) . "<CR>"

" 2}}} =========================CamelCaseMotion========================== {{{2

let g:camelcasemotion_leader = 'g'

" 2}}} ============================EasyMotion============================ {{{2

noremap [emotion] <Nop>
map 0 [emotion]

let g:EasyMotion_leader_key = '[emotion]'

" 2}}} =============================HistWin============================== {{{2

let g:undo_tree_help = 0
let g:undo_tree_dtl = 0
let g:undo_tree_width = 40
" let g:undo_tree_nomod = 0

" 2}}} ==============================Cycle=============================== {{{2

let g:cycle_no_mappings = 1
let g:cycle_max_conflict = 7
" let g:cycle_max_conflict = 1
let g:cycle_phased_search = 1

nmap <silent> <LocalLeader>a <Plug>CycleNext
vmap <silent> <LocalLeader>a <Plug>CycleNext
nmap <silent> <Leader>a <Plug>CyclePrev
vmap <silent> <Leader>a <Plug>CyclePrev

let g:cycle_default_groups = [
      \   [['true', 'false']],
      \   [['yes', 'no']],
      \   [['on', 'off']],
      \   [['+', '-']],
      \   [['>', '<']],
      \   [['"', "'"]],
      \   [['==', '!=']],
      \   [['0', '1']],
      \   [['and', 'or']],
      \   [['in', 'out']],
      \   [['up', 'down']],
      \   [['min', 'max']],
      \   [['get', 'set']],
      \   [['add', 'remove']],
      \   [['to', 'from']],
      \   [['read', 'write']],
      \   [['save', 'load', 'restore']],
      \   [['next', 'previous', 'prev']],
      \   [['only', 'except']],
      \   [['without', 'with']],
      \   [['exclude', 'include']],
      \   [['width', 'height']],
      \   [['asc', 'desc']],
      \   [['start', 'end']],
      \   [['ÊòØ', 'Âê¶']],
      \   [['‰∏ä', '‰∏ã']],
      \   [['Â∑¶', 'Âè≥']],
      \   [['Ââç', 'Âæå']],
      \   [['Áî∑', 'Â•≥']],
      \   [['east', 'west']],
      \   [['south', 'north']],
      \   [['prefix', 'suffix']],
      \   [['decode', 'encode']],
      \   [['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday',
      \     'Friday', 'Saturday'], ['hard_case', {'name': 'Days'}]],
      \   [['{:}', '[:]', '(:)'], 'sub_pairs'],
      \   [['Ôºà:Ôºâ', '„Äå:„Äç', '„Äé:„Äè'], 'sub_pairs'],
      \ ]

" {{{3 ==============================Ruby, Rails==============================

let g:cycle_default_groups += [
      \   [["if", "unless"]],
      \   [["blank", "present"]],
      \   [["while", "until"]],
      \   [["begin", "end"]],
      \   [["foreign_key", "primary_key"]],
      \   [["inspect", "to_yaml"]],
      \   [["do:end", "{:}"], 'sub_pairs'],
      \ ]

" 3}}} ===============================CSS================================ {{{3

let g:cycle_default_groups += [
      \   [["none", "block"]],
      \   [["show", "hide"]],
      \   [["left", "right"]],
      \   [["top", "bottom"]],
      \   [["margin", "padding"]],
      \   [["before", "after"]],
      \   [["absolute", "relative"]],
      \   [["horizontal", "vertical"]],
      \   [["first", "last"]],
      \ ]

" 3}}} ===============================HTML=============================== {{{3

let g:cycle_default_groups += [
      \   [['h1', 'h2', 'h3'], 'sub_tag'],
      \   [['ul', 'ol'], 'sub_tag'],
      \   [['header', 'footer']],
      \   [['em', 'strong', 'small'], 'sub_tag'],
      \ ]

" 3}}} ================================JS================================ {{{3

let g:cycle_default_groups += [
      \   [['focus', 'blur']],
      \ ]

" 3}}} ==============================Others============================== {{{3
let g:cycle_default_groups += [
      \   [['Êó•', '‰∏Ä', '‰∫å', '‰∏â', 'Âõõ', '‰∫î', 'ÂÖ≠']],
      \ ]

" 3}}}

let g:cycle_default_groups_for_ruby = [
      \   [['accessible', 'protected']],
      \   [['stylesheet_link_tag ', 'javascript_include_tag ']],
      \ ]

" 2}}} =============================AmbiCmd============================== {{{2

" cnoremap <expr> <Space> ambicmd#expand("\<Space>")
" cnoremap <expr> <CR> ambicmd#expand("\<CR>")

" 2}}} ===========================DelimitMate============================ {{{2

let delimitMate_matchpairs = "(:),[:],{:},„Äå:„Äç,Ôºà:Ôºâ"
let delimitMate_excluded_regions = ""
" let delimitMate_expand_space = 1
" let delimitMate_expand_cr = 1
" let delimitMate_smart_quotes = 0
" let delimitMate_smart_matchpairs = ''
let delimitMate_balance_matchpairs = 1

" 2}}} ============================SmartWord============================= {{{2

" if exists('g:loaded_smartword')
"   map w  <Plug>(smartword-w)
"   map b  <Plug>(smartword-b)
"   map e  <Plug>(smartword-e)
"   map ge  <Plug>(smartword-ge)
" endif

" 2}}} =============================FakeClip============================= {{{2

" let g:fakeclip_no_default_key_mappings = 1

" 2}}} ===========================PrettyPrint============================ {{{2

" let g:prettyprint_show_expression = 1
let g:prettyprint_strin = ['split']

" 2}}} ===============================Ref================================ {{{2

let g:ref_cache_dir = expand('~/.vim/ref-cache')

autocmd FileType ref-bingzh call s:initialize_ref_viewer_bingzh()
function! s:initialize_ref_viewer_bingzh()
  setlocal number nowrap
  setlocal noreadonly
  setlocal modifiable
  setlocal foldmethod=expr foldlevel=1 foldexpr=RefBingZhFold(v:lnum)
endfunction

nnoremap <silent> K :call ref#jump('normal', 'bingzh')<CR>
xnoremap <silent> K :call ref#jump('visual', 'bingzh')<CR>
cnoreabbrev <expr> k ((getcmdtype() == ':' && getcmdpos() <= 2) ? 'Ref bingzh' : 'k')

nnoremap <silent> <LocalLeader>K :normal! K<CR>
xnoremap <silent> <LocalLeader>K :normal! K<CR>

function! RefBingZhFold(line)
  return <SID>ref_bingzh_fold(a:line)
endfunction

function! s:ref_bingzh_fold(line)
  let splitter = '\v ##$'
  if getline(a:line) =~ splitter
    return '>1'
  elseif getline(a:line+1) =~ splitter
    return '<1'
  else
    return '='
  endif
endfunction

" 2}}} ===========================Open-Browser=========================== {{{2

nmap <Leader><CR> <Plug>(openbrowser-smart-search)
vmap <Leader><CR> <Plug>(openbrowser-smart-search)
nmap <Leader>s<CR> <Plug>(openbrowser-search)
vmap <Leader>s<CR> <Plug>(openbrowser-search)

let g:openbrowser_search_engines = {
      \   'morebile': 'http://www.google.com.tw/m/search?site=dictionary&gdm=1&wtr=1&q={query}',
      \   'dictionary': 'http://www.google.com/dictionary?q={query}',
      \   'google': 'http://google.com/search?q={query}',
      \ }
let g:openbrowser_default_search = 'morebile'

let g:openbrowser_iskeyword = join(
      \   range(char2nr('A'), char2nr('Z'))
      \   + range(char2nr('a'), char2nr('z'))
      \   + range(char2nr('0'), char2nr('9'))
      \   + ['_', ':', '/', '.', '-', '+', '%', '#', '?', '&', '=', ';', '@', '$', ',', '[', ']', '!', "(", ")", "*", "~", ],
      \ ',')

" 2}}} ============================LargeFile============================= {{{2

let g:LargeFile           = 40
" let g:LargeFile           = 0.40
let g:LargeFile_size_unit = 1024    " KB
let g:LargeFile_patterns  = '*.log,*.log.1,*.sql'
let g:LargeFile_verbose   = 0
autocmd User LargeFileRead call s:large_file_read()
autocmd User LargeFile call s:large_file_detected()

function! s:large_file_detected()
  let ext_name = expand('%:e')
  if ext_name == 'log'
    " nnoremap <buffer> <LocalLeader>ddd :EmptyFile<CR>
  elseif ext_name == 'sql'
    " set syntax=sql
  endif
endfunction

function! s:large_file_read()
  let dir_name = expand('%:p:h')
  if dir_name =~ '/home/www/fc/\(\w\+/\)\?log'
    if &fileencoding != 'utf-8'
      edit! ++enc=utf-8
    endif
    syntax match railslogEscape '\e\[[0-9;]*m' conceal
  elseif dir_name == '/home/www/logs'
    set syntax=httplog
  endif
endfunction

" 2}}}

" 1}}}


" {{{1 ============================TabLine Setting============================

function! SetTabLine()
  let tabMinWidth = 0
  let tabMaxWidth = 40
  let tabMinWidthResized = 15
  let tabScrollOff = 5
  let tabEllipsis = '‚Ä¶'
  let tabDivideEquel = 0

  let s:tabLineTabs = []

  let tabCount = tabpagenr('$')
  let tabSel = tabpagenr()

  for i in range(tabCount)
    let tabnr = i + 1
    let buflist = tabpagebuflist(tabnr)
    let winnr = tabpagewinnr(tabnr)
    let bufnr = buflist[winnr - 1]

    let filename = bufname(bufnr)
    let filename = fnamemodify(filename, ':p:t')
    let buftype = getbufvar(bufnr, '&buftype')
    if filename == ''
      if buftype == 'nofile'
        let filename .= '[Scratch]'
      else
        let filename .= '[New]'
      endif
    endif
    let split = ''
    let winCount = tabpagewinnr(tabnr, '$')
    if winCount > 1
      let split .= winCount
    endif
    let flag = ''
    if getbufvar(bufnr, '&modified')
      let flag .= '+'
    endif
    if strlen(flag) > 0 || strlen(split) > 0
      let flag .= ' '
    endif

    call add(s:tabLineTabs, {'n': tabnr, 'split': split, 'flag': flag, 'filename': filename})
  endfor

  let s = ''
  let l:tabLineTabs = deepcopy(s:tabLineTabs)

  if s:TabLineTotalLength(l:tabLineTabs) > &columns
    unlet i
    for i in l:tabLineTabs
      let tabLength = s:CalcTabLength(i)
      if tabLength < tabMinWidth
        let i.filename .= repeat(' ', tabMinWidth - tabLength)
      elseif tabMaxWidth > 0 && tabLength > tabMaxWidth
        let reserve = tabLength - StrWidth(i.filename) + StrWidth(tabEllipsis)
        if tabMaxWidth > reserve
          let i.filename = StrCrop(i.filename, (tabMaxWidth - reserve), '~') . tabEllipsis
        endif
      endif
    endfor
  endif
  if tabDivideEquel
    if s:TabLineTotalLength(l:tabLineTabs) > &columns
      let divideWidth = max([tabMinWidth, tabMinWidthResized, &columns / tabCount, StrWidth(tabEllipsis)])
      unlet i
      for i in l:tabLineTabs
        let tabLength = s:CalcTabLength(i)
        if tabLength > divideWidth
          let i.filename = StrCrop(i.filename, divideWidth - StrWidth(tabEllipsis), '~') . tabEllipsis
        endif
      endfor
    endif
  endif
  let rhWidth = 0
  let t = tabCount - 1
  let rhTabStart = min([tabSel - 1, tabSel - tabScrollOff])
  while t >= max([rhTabStart, 0])
    let tab = l:tabLineTabs[t]
    let tabLength = s:CalcTabLength(tab)
    let rhWidth += tabLength
    let t -= 1
  endwhile
  while rhWidth >= &columns
    let tab = l:tabLineTabs[-1]
    let tabLength = s:CalcTabLength(tab)
    let lastTabSpace = &columns - (rhWidth - tabLength)
    let rhWidth -= tabLength
    if rhWidth > &columns
      call remove(l:tabLineTabs, -1)
    else
      if tabSel <= tabScrollOff || tabSel < tabCount - tabScrollOff
        let tab.flag .= '>' . lastTabSpace
      endif
    endif
  endwhile

  unlet i
  for i in l:tabLineTabs
    let tabnr = i.n

    let split = ''
    if strlen(i.split) > 0
      if tabnr == tabSel
        let split = '%#TabLineSplitNrSel#' . i.split .'%#TabLineSel#'
      else
        let split = '%#TabLineSplitNr#' . i.split .'%#TabLine#'
      endif
    endif

    let text = ' ' . split . i.flag . i.filename . ' '

    if i.n == l:tabLineTabs[-1].n
        if match(i.flag, '>\d\+') > -1 || i.n < tabCount
        let lastTabSpace = matchstr(i.flag, '>\zs\d\+')
        let i.flag = substitute(i.flag, '>\d\+', '', '')
        if lastTabSpace <= strlen(i.n)
          if lastTabSpace == 0
            let s = strpart(s, 0, strlen(s) - 1)
          endif
          let s .= '%#TabLineMore#>'
          continue
        else
          let text = ' ' . i.split . i.flag . i.filename . ' '
          let text = StrCrop(text, (lastTabSpace - strlen(i.n) - 1), '~') . '%#TabLineMore#>'
          let text = substitute(text, ' ' . i.split, ' ' . split, '')
        endif
        endif
    endif

    let s .= '%' . tabnr . 'T'  " start of tab N

    if tabnr == tabSel
      let s .= '%#TabLineNrSel#' . tabnr . '%#TabLineSel#'
    else
      let s .= '%#TabLineNr#' . tabnr . '%#TabLine#'
    endif

    let s .= text

  endfor

  let s .= '%#TabLineFill#%T'
  if exists('s:tabLineResult') && s:tabLineResult !=# s
    let s:tabLineNeedRedraw = 1
  endif
  let s:tabLineResult = s
  return s
endfunction

function! s:CalcTabLength(tab)
  return strlen(a:tab.n) + 2 + strlen(a:tab.split) + strlen(a:tab.flag) + StrWidth(a:tab.filename)
endfunction

function! s:TabLineTotalLength(dict)
  let length = 0
  for i in (a:dict)
    let length += strlen(i.n) + 2 + strlen(i.split) + strlen(i.flag) + StrWidth(i.filename)
  endfor
  return length
endfunction

" 1}}}


" {{{1 ===============================Functions===============================

" {{{2 =====================Clear redundant Tab and Space=====================

command! -nargs=0 TidySpaces call TidySpaces()
function! TidySpaces()
  let oldCursor = getpos(".")
  %s/\r\+$//ge
  %s/\t/    /ge
  %s/\s\+$//ge
  call setpos('.', oldCursor)
endfunction

" 2}}} ==============================Encode============================== {{{2

command! -bang -bar -complete=file -nargs=? Utf8
      \ edit<bang> ++enc=utf-8 <args>
command! -bang -bar -complete=file -nargs=? Big5
      \ edit<bang> ++enc=big5 <args>

" 2}}} ============================Sudo Write============================ {{{2

function! SudoWrite()
  let modified = &l:modified
  setlocal nomodified
  silent! execute 'write !sudo tee % >/dev/null'
  let &l:modified = v:shell_error ? modified : 0
endfunction

" 2}}} ===================Clear/Recover Search Pattern=================== {{{2

" ÂïèÈ°åÔºölet @/ = '' ÂæåÂÜçÊåâ nÔºå‰∏çÁü•ÁÇ∫‰ªÄÈ∫ºÂèàÊúÉÊîπËÆä @/ ÁöÑÂÄº
" Êõø‰ª£‰ΩúÊ≥ïÁÇ∫‰ΩøÁî® :nohlsearchÔºå‰ΩÜÁÑ°Ê≥ïÁ¢∫Ë™çÁõÆÂâçÊòØÂê¶Â∑≤Êúâ highlightÔºå
" ÊïÖÁî®Êéâ <F3> <F4> ÂÖ©ÂÄãÈçµ‰Ωú mapping„ÄÇ
"
" let g:lastSearchPattern = @/
" function! ToggleSearchPattern()
"   if @/ != ''
"     let g:lastSearchPattern = @/
"     let @/ = ''
"   else
"     let @/ = g:lastSearchPattern
"   endif
" endfunction

" nmap <silent> <F3> :call ToggleSearchPattern()<CR>
" imap <silent> <F3> <C-O>:call ToggleSearchPattern()<CR>

" 2}}} ======================Save/Restore Position======================= {{{2

function! SavePos()
  let s:save_pos = getpos(".")
endfunction

function! RestorePos()
  call setpos('.', s:save_pos)
endfunction

" 2}}} ======================Save/Restore Register======================= {{{2

function! SaveReg(...)
  let l:name = a:0 ? a:1 : v:register
  let s:save_reg = [getreg(l:name), getregtype(l:name)]
endfunction

function! RestoreReg(...)
  let l:name = a:0 ? a:1 : v:register
  if exists('s:save_reg')
    call setreg(l:name, s:save_reg[0], s:save_reg[1])
  endif
endfunction

" 2}}} ========================Save/Restore Mark========================= {{{2

function! SaveMark(...)
  let l:name = a:0 ? a:1 : 'm'
  let s:save_mark = getpos("'" . l:name)
endfunction

function! RestoreMark(...)
  let l:name = a:0 ? a:1 : 'm'
  call setpos("'" . l:name, s:save_mark)
endfunction

" 2}}} ==========================String Length=========================== {{{2

function! StrWidth(str)
  if exists('*strwidth')
    return strwidth(a:str)
  else
    let strlen = strlen(a:str)
    let mstrlen = strlen(substitute(a:str, ".", "x", "g"))
    if strlen == mstrlen
      return strlen
    else
      return strlen
    endif
  endif
endfunction

" 2}}} =======================Cut Redundant Chars======================== {{{2

function! StrCrop(str, len, ...)
  let l:padChar = a:0 > 0 ? a:1 : ' '
  if exists('*strwidth')
    let text = substitute(a:str, '\%>' . a:len . 'c.*', '', '')
    let remainChars = split(substitute(a:str, text, '', ''), '\zs')
    while strwidth(text) < a:len
      let longer = len(remainChars) > 0 ? (text . remove(remainChars, 0)) : text
      if strwidth(longer) < a:len
        let text = longer
      else
        let text .= l:padChar
      endif
    endwhile
    return text
  else
    return substitute(a:str, '\%>' . a:len . 'c.*', '', '')
  endif
endfunction

" 2}}} ==========================Custom diffoff========================== {{{2

command! MyDiffOff call MyDiffOff()
function! MyDiffOff()
  if &diff
    setlocal diff& scrollbind& cursorbind& wrap& foldcolumn&
    set scrollopt=ver,hor,jump
    let &l:foldmethod = exists('b:save_foldmethod') ? b:save_foldmethod : 'marker'
  else
    echomsg 'Not in diff mode.'
  endif
endfunction

" 2}}} ======================Context Sensitive H,L======================= {{{2

nnoremap <silent> H :<C-u>call HContext()<CR>
nnoremap <silent> L :<C-u>call LContext()<CR>
xnoremap <silent> H <ESC>:<C-u>call HContext()<CR>mzgv`z
xnoremap <silent> L <ESC>:<C-u>call LContext()<CR>mzgv`z

function! HContext()
  let l:moved = MoveCursor("H")
  if !l:moved && line('.') != 1
    " execute "normal! " . "\<ScrollWheelUp>H"
    execute "normal! " . "5kH"
  endif
endfunction

function! LContext()
  let l:moved = MoveCursor("L")

  if !l:moved && line('.') != line('$')
    " execute "normal! " . "\<ScrollWheelDown>L"
    execute "normal! " . "5jL"
  endif
endfunction

function! MoveCursor(key)
  let l:cnum = col('.')
  let l:lnum = line('.')
  let l:wline = winline()

  execute "normal! " . v:count . a:key
  let l:moved =  l:cnum != col('.') || l:lnum != line('.') || l:wline != winline()

  return l:moved
endfunction

" 2}}} ==============================Scroll============================== {{{2

function! s:scroll_down(...)
  let mode = a:0 ? a:1 : 'n'
  let l:count = a:0 > 1 ? a:2 : 2

  if has("gui_running")
    return '5j'
  else
    return repeat("\<ScrollWheelDown>", l:count)
  endif
endfunction

function! s:scroll_up(...)
  let mode = a:0 ? a:1 : 'n'
  let l:count = a:0 > 1 ? a:2 : 2

  if has("gui_running")
    return '5k'
  else
    return repeat("\<ScrollWheelUp>", l:count)
  endif
endfunction

" 2}}} ==========================Smart Home/End========================== {{{2

function! SmartHome(mode)
  let curcol = col(".")
  " gravitate towards beginning for wrapped lines
  if curcol > indent(".") + 2
    call cursor(0, curcol - 1)
  endif
  if curcol == 1 || curcol > indent(".") + 1
    if &wrap
      normal! g^
    else
      normal! ^
    endif
  else
    if &wrap
      normal! g0
    else
      normal! 0
    endif
  endif
  if a:mode == "v"
    call SaveMark('m')
    call setpos("'m", getpos('.'))
    normal! gv`m
    call RestoreMark('m')
  endif
  return ""
endfunction

function! SmartEnd(mode)
  let curcol = col(".")
  let lastcol = a:mode == "i" ? col("$") : col("$") - 1
  " gravitate towards ending for wrapped lines
  if curcol < lastcol - 1
    call SaveReg()
    normal! yl
    let l:charlen = byteidx(getreg(), 1)
    call cursor(0, curcol + l:charlen)
    call RestoreReg()
  endif
  if curcol < lastcol
    if &wrap
      normal! g$
    else
      normal! $
    endif
  else
    normal! g_
  endif
  " correct edit mode cursor position, put after current character
  if a:mode == "i"
    call SaveReg()
    normal! yl
    let l:charlen = byteidx(getreg(), 1)
    call cursor(0, col(".") + l:charlen)
    call RestoreReg()
  endif
  if a:mode == "v"
    call SaveMark('m')
    call setpos("'m", getpos('.'))
    normal! gv`m
    call RestoreMark('m')
  endif
  return ""
endfunction

" 2}}} ============================ClipBoard============================= {{{2

function! Putclip(type, ...) range
  let save_sel = &selection
  let &selection = "inclusive"
  let save_reg = @@
  if a:type == 'n'
    silent execute a:firstline . "," . a:lastline . "y"
  elseif a:type == 'c'
    silent execute a:1 . "," . a:2 . "y"
  else
    silent execute "normal! `<" . a:type . "`>y"
  endif
  call system('putclip', @@)
  let &selection = save_sel
  let @@ = save_reg
endfunction

if has('clipboard')
  if $OSTYPE == 'cygwin' || has("gui_win32")
    noremap <silent> <LocalLeader>y "*y
    inoremap <silent> <LocalLeader>y <C-O>"*y
    if has("gui_win32")
      noremap! <S-Insert> <C-R>*
    endif
  elseif $OSTYPE == 'linux-gnu'
    noremap <silent> <LocalLeader>y "+y
    inoremap <silent> <LocalLeader>y <C-O>"+y
  endif
else
  vnoremap <silent> <LocalLeader>y :call Putclip(visualmode(), 1)<CR>
  nnoremap <silent> <LocalLeader>y :call Putclip('n', 1)<CR>
  inoremap <silent> <LocalLeader>y <C-O>:call Putclip('n', 1)<CR>
endif

function! Getclip()
  let save_reg = @@
  let @@ = system('getclip')
  setlocal paste
  execute 'normal! p'
  setlocal nopaste
  let @@ = save_reg
endfunction

if has('clipboard')
  if $OSTYPE == 'cygwin' || has("gui_win32")
    nnoremap <silent> <LocalLeader>p "*p
    inoremap <silent> <LocalLeader>p <C-O>"*p
  elseif $OSTYPE == 'linux-gnu'
    nnoremap <silent> <LocalLeader>p "+p
    inoremap <silent> <LocalLeader>p <C-O>"+p
  endif
else
  nnoremap <silent> <LocalLeader>p :call Getclip()<CR>
  inoremap <silent> <LocalLeader>p <C-O>:call Getclip()<CR>
endif

" 2}}} =============================LastTab============================== {{{2

function! LastTab(act)

  let lt = g:lasttab
  let tabClosed = tabpagenr('$') < lt.knownLength ? 1 : 0

  if a:act ==# 'TabLeave'
    if !tabClosed
      let lt.prevLeave = lt.leave
    elseif lt.prevLeave > tabpagenr()
      let lt.prevLeave -= 1
    endif
    let lt.leave = tabpagenr()
  elseif a:act ==# 'switch'
    if tabClosed
      let lastTab = lt.prevLeave > tabpagenr() ? lt.prevLeave -1  : lt.prevLeave
    else
      let lastTab = lt.leave
    endif
    if lastTab == tabpagenr()
      echo 'Already on last tab.'
    else
      execute "tabnext " . lastTab
    endif
  endif

  let lt.knownLength = tabpagenr('$')

endfunction

if !exists('g:lasttab')
  let g:lasttab = {'leave':1, 'prevLeave':1, 'knownLength':1}
endif

autocmd TabLeave * call LastTab('TabLeave')
" autocmd TabEnter,VimEnter * :call LastTab('TabEnter')
" autocmd BufLeave * :call LastTab('TabEnter')
autocmd TabEnter * call LastTab('TabEnter')

nnoremap <silent> <LocalLeader>t :call LastTab('switch')<CR>
inoremap <silent> <LocalLeader>t <C-\><C-N>:call LastTab('switch')<CR>

" 2}}} =========================HighLight Group========================== {{{2

function! SynStackInfo()
  let synStack =  synstack(line("."), col("."))
  if len(synStack) == 0
    echomsg 'No synID here.'
  else
    let result = []
    for syn in synStack
      call add(result, SynInfo(syn))
    endfor
    redraw
    let level = 0
    for list in result
      execute "echohl " . list[0]
      echomsg repeat(' ', level) . list[1]
      let level += 1
      echohl None
    endfor
  endif
endfunction

function! SynInfo(syn)
  let synAttr =  synIDattr(a:syn, "name")
  if synAttr == ''
    echomsg 'No synID here.'
  else
    let idTrans = synIDtrans(a:syn)
    let syn = synIDattr(idTrans, "name")
    return [syn, synAttr . " - " . syn . " {fg: " . synIDattr(idTrans, 'fg') . ', bg: ' . synIDattr(idTrans, 'bg') . "}" ]
  endif
endfunction

" 2}}} ============================TabMessage============================ {{{2

function! TabMessage(cmd)
  redir => redirMessage
  silent execute a:cmd
  redir END
  tabnew
  silent put=redirMessage
  0,2delete_
  set nomodified
  setlocal buftype=nofile
  setlocal bufhidden=hide
  setlocal noswapfile
  setlocal nobuflisted
endfunction

command! -nargs=+ -complete=command TabMessage call TabMessage(<q-args>)

" 2}}} ====================Move Windown into Tab Page==================== {{{2

function! s:move_window_into_tab_page(...)
  let target_tabpagenr = a:0 > 0 ? a:1 : 0
  let open_relative = a:0 > 1 ? a:2 : 1

  if target_tabpagenr > tabpagenr('$')
    let target_tabpagenr = tabpagenr('$')
  endif

  let original_tabnr = tabpagenr()
  let target_bufnr = bufnr('')
  let window_view = winsaveview()

  if target_tabpagenr == 0
    tabnew
    if !open_relative
      tabmove
    endif
    execute target_bufnr 'buffer'
    let target_tabpagenr = tabpagenr()
  else
    execute target_tabpagenr 'tabnext'
    topleft new  " FIXME: be customizable?
    execute target_bufnr 'buffer'
  endif
  call winrestview(window_view)

  execute original_tabnr 'tabnext'
  if 1 < winnr('$')
    close
  else
    enew
  endif

  execute target_tabpagenr 'tabnext'
endfunction

command! -nargs=* MoveIntoTabpage call <SID>move_window_into_tab_page(<f-args>)

" 2}}} =======================EvalVimScriptRegion======================== {{{2

function! EvalVimScriptRegion(s, e)
  let lines = getline(a:s,a:e)
  let file = tempname()
  call writefile(lines,file)
  redir @e
  silent execute ':source ' . file
  call delete(file)
  redraw
  redir END
  echo "Region evaluated."

  if strlen(getreg('e')) > 0
    10new
    redraw
    silent file "EvalResult"
    setlocal noswapfile buftype=nofile bufhidden=wipe
    setlocal nobuflisted nowrap cursorline nonumber foldcolumn=0
    set filetype=eval
    syntax match ErrorLine +^E\d\+:.*$+
    highlight link ErrorLine Error
    silent $put =@e
  endif
endfunction

augroup VimEval
  autocmd!
  autocmd filetype vim :command! -range Eval :call EvalVimScriptRegion(<line1>, <line2>)
  autocmd filetype vim :vnoremap <silent> <F5> <C-\><C-N>:call SavePos()<CR>gv:Eval<CR>:call RestorePos()<CR>
augroup END

" 2}}} ==========================Help Fold Expr========================== {{{2

function! HelpDelimFoldLevel(line)
  if  getline(a:line-1)=~'=\{78,\}'
    return '>1'
  elseif getline(a:line+1)=~'=\{78,\}'
    return '<1'
  else
    return '='
  endif
endfunction

" 2}}} ==================Help Hyper Text Entry Justify=================== {{{2

function! HelpHyperTextEntryJustify()
  let save_isk = &l:iskeyword
  let save_et = &l:expandtab
  let &l:isk = '!-~,^*,^|,^",192-255'
  let &l:expandtab = 1
  .retab!
  call setline(".",
        \ substitute(
        \   getline('.'),
        \   '\v(.*)(\s\*\k+\*)',
        \   '\=submatch(1) . repeat(" ", &textwidth - strlen(submatch(0))) . submatch(2)'
        \   , ""
        \ ))

  let &l:isk = save_isk
  let &l:et = save_et
  .retab!
endfunction

" 2}}} =================CamelCase and UnderScore Switch================== {{{2

function! WordTransform()
  let w = expand("<cword>")
  let x = ''
  let c = strpart(getline('.'), col('.') - 1, 1)
  if match(w, '_') > -1
    let x = substitute(w, '_\([a-z]\)', '\u\1', 'g')
  else
    let x = substitute(w, '\C[A-Z]', '_\L\0', 'g')
  endif
  if x == w
    echohl WarningMsg | echomsg "Not a camelCased/under_scored word." | echohl None
    return
  endif
  if match(w, c) < 0
    execute "normal! f" . strpart(w, 0, 1)
    execute "normal! \"_ciw\<C-R>=x\<CR>"
  else
    execute "normal! \"_ciw\<C-R>=x\<CR>"
  endif
endfunction

nnoremap <LocalLeader>x :call WordTransform()<CR>

" 2}}} =====================Symbol and String Switch===================== {{{2

  " function! SymbolStringTransform()
  "     let w = expand("<cword>")
  "     let x = ''
  "     let c = strpart(getline('.'), col('.') - 1, 1)
  " endfunction

" 2}}} ==============================JSLint============================== {{{2

command! -nargs=* JSLint call JSLint(<f-args>)
function! JSLint(...)
  if !executable('jslint')
    echohl WarningMsg | echoerr "jslint command not found." | echohl None
    return
  endif
  let input    = expand('%')
  let interact = a:0 > 0 ? a:1 : 0
  let options  = a:0 > 1 ? a:2 : ''

  if &modified
    echomsg 'No write since last change, write before lint? (y/n) '
    let ans = getchar()
    if nr2char(ans) == 'y' | w
    elseif nr2char(ans) != 'n' | redraw! | echomsg 'JSLint aborted.' | return
    endif
  endif

  if &filetype == 'javascript'
    let cmd = 'jslint ' . input . ' ' . options
    if interact
      echomsg 'JSLint ' . input . '? (y/n) ' | redraw
      let yes = getchar()
      if nr2char(yes) == 'y'
        return DoJSLint(cmd, input)
      else
        redraw!
        echomsg 'JSLint aborted.'
        return
      endif
    else
      return DoJSLint(cmd, input)
    endif
  else
    echohl WarningMsg | echomsg "Unsupported filetype." | echohl None
  endif
endfunction

function! DoJSLint(cmd, file)
  echomsg "JSLint in progress..."
  let ret = system(a:cmd)
  if v:shell_error
    cexpr ret
    if len(getqflist()) > 0
      QFix!<CR>
    endif
  else
    redraw
    echomsg "No problems found in " . a:file
    return
  endif
endfunction

" 2}}} =========================Closure Compiler========================= {{{2

if !exists('g:enable_js_compress')
  let g:enable_js_compress = 1
endif

command! ToggleJsCompress call ToggleJsCompress()
function! ToggleJsCompress()
  let g:enable_js_compress = !g:enable_js_compress
endfunction

command! -bang -nargs=* JsCompress call JsCompress(<bang>0, <f-args>)
function! JsCompress(save, ...)
  if !g:enable_js_compress
    return
  endif
  let jar      = expand('~/') . 'bin/closure-compiler.jar'
  let defaults = ' --compilation_level=SIMPLE_OPTIMIZATIONS'
              \ . ' --create_source_map ~/closure-compiler-map'
              \ . ' --warning_level=QUIET'
  let input    = expand('%')

  let interact = a:0 > 0 ? a:1 : 0
  let options  = a:0 > 1 ? a:2 : ''

  if &modified
    echomsg 'No write since last change, write before compression? (y/n) '
    let ans = getchar()
    if nr2char(ans) == 'y' | w
    elseif nr2char(ans) != 'n' | redraw! | echomsg 'Compression aborted.' | return
    endif
  endif

  if !executable(jar)
    echohl WarningMsg | echoerr "Can't execute java jar." | echohl None
    return
  endif

  if !a:save
    let output = tempname()
  elseif match(input, '-debug\.js$') > 0
    let output = substitute(input, '-debug\.js$', '\.js', '')
  elseif match(input, '-src\.js$') > 0
    let output = substitute(input, '-src\.js$', '\.js', '')
  else
    let output = substitute(input, '\.js$', '\.min\.js', '')
  endif

  if &filetype == 'javascript'
    if executable('cygpath')
      let cmd = 'java -jar `cygpath -wp ' . jar . '`' . defaults
            \ . ' ' . options
            \ . ' --js=`cygpath -wp ' . input . '`'
            \ . ' --js_output_file=`cygpath -wp ' . output . '`'
    else
      let cmd = 'java -jar ' . jar . defaults . ' ' .options . ' --js=' . input . ' --js_output_file=' . output
    endif
    let cmd .= " 2>&1 \\\\| sed '/^$/d'"

    if interact
      echomsg 'Compress ' . input . ' to ' . output . '? (y/n/s (skip in this session)) '
      let yes = getchar()
      if nr2char(yes) == 'y'
        return DoJsCompress(cmd, output, a:save)
      elseif nr2char(yes) == 's'
        call ToggleJsCompress()
        redraw!
        echomsg 'Disable compression in this session (run :ToggleJsCompress for toggle.)'
        return
      else
        redraw!
        echomsg 'Compression aborted.'
        return
      endif
    else
      return DoJsCompress(cmd, output, a:save)
    endif
  else
    echohl WarningMsg | echomsg "Unsupported filetype." | echohl None
  endif
endfunction

function! DoJsCompress(cmd, file, save)
  let makeprg_orig = &makeprg
  execute "set makeprg=" . escape(a:cmd, ' \"')
  silent make
  let &makeprg = makeprg_orig
  if a:save
    let ret = a:file
  else
    let ret = join(readfile(a:file), "\n")
    call delete(a:file)
  endif
  if len(getqflist()) == 0
    redraw!
    echomsg "Compression completed." (a:save ? '' : '(result written to temporarily file.)')
    return ret
  else
    return 0
  endif
endfunction

" 2}}} ===========================Bookmarklet============================ {{{2

command! -nargs=* Bookmarklet call Bookmarklet(<f-args>)
function! Bookmarklet(...)
  let result = JsCompress(0, 0, '--compilation_level=WHITESPACE_ONLY')
  if len(getqflist()) == 0 && strlen(result) > 0
    let reuse_win = 0
    for winnr in tabpagebuflist(tabpagenr())
      if bufname(winnr) == '[Bookmarklet]'
        execute winnr . 'wincmd w'
        let reuse_win = winnr
      endif
    endfor
    if !reuse_win
      execute 'belowright 5new [Bookmarklet]'
      setlocal noswapfile bufhidden=wipe winfixheight filetype=javascript
    endif
    let result = substitute(result, '[\n]', '', '')
    setlocal buftype=
    call setline(1, 'javascript:(function(){' . result . '})();')
    if has('ruby')
      ruby require("uri"); VIM::Buffer.current.line = URI.escape(VIM::Buffer.current.line);
    else
      echohl WarningMsg | echomsg "No ruby support. Can't do URI encoding." | echohl None
    endif
    setlocal buftype=nofile
  endif
endfunction

" 2}}} ======================Toggle QuickFix Window====================== {{{2

command! -bang -nargs=? QFix call QFixToggle(<bang>0)
fu! QFixToggle(forced)
  if exists("g:qfix_win") && a:forced == 0
    cclose
    unlet g:qfix_win
  else
    copen 10
    let g:qfix_win = bufnr("$")
  endif
endfunction

nnoremap <silent> <LocalLeader>q :QFix<CR>

" 2}}} =======================Search Select String======================= {{{2

vnoremap * :<C-U>set hlsearch<CR>:call <SID>search_selected_text_literaly('n')<CR>
vnoremap # :<C-U>set hlsearch<CR>:call <SID>search_selected_text_literaly('N')<CR>

function! s:search_selected_text_literaly(search_command)
  call SaveReg('0')
  call SaveReg('"')

  normal! gvy
  let pattern = escape(@0, '\')
  let pattern = substitute(pattern, '\V\n', '\\n', 'g')
  let @/ = pattern
  call histadd('/', '\V' . pattern)
  execute 'normal!' a:search_command
  let v:searchforward = a:search_command ==# 'n'

  call RestoreReg('0')
  call RestoreReg('"')
endfunction

" 2}}} ===========================Close Layout=========================== {{{2

command! -nargs=0 QuickOff call <SID>quick_off()
function! s:quick_off()
  if winnr('$') > 1
    if <SID>ref_window_off()
      return
    elseif exists('t:gitdiffall_info')
      execute 'GitDiffOff'
    endif
  endif
endfunction

function! s:ref_window_off()
  let win_count = winnr('$')
  silent windo call <SID>ref_quit()
  execute 'wincmd t'
  return win_count > winnr('$')
endfunction

function! s:ref_quit()
  if &filetype =~ 'ref-\w'
    execute "quit"
  endif
endfunction

" 2}}} =====================Text Object for Comment====================== {{{2

vnoremap <silent> ac :<C-U>call TxtObjComment()<CR>
onoremap <silent> ac :<C-U>call TxtObjComment()<CR>

function! TxtObjComment()
  if exists("g:syntax_on")
    if !IsInComment()
      echomsg 'Not in a Comment region.'
      return 0
    else
      call cursor(SearchContinuousComment(0, line(".")))
      normal! 0V
      call cursor(SearchContinuousComment(1, line(".")))
    endif
  else
    echohl ErrorMsg | echoerr "TxtObjComment: syntax highlighting not enabled." | echohl None
  endif
endfunction

function! SearchContinuousComment(forward, lnum)
  let line = a:lnum
  while line > 0 && line <= line("$")
    let next = a:forward ? line + 1 : line - 1
    if next > 0 && next < line("$") && IsInComment(next)
      let line = next
    else
      break
    endif
  endwhile
  return [line, 0]
endfunction

function! IsInComment(...)
  let lnum = a:0 > 0 ? a:1 : line(".")
  let col = a:0 > 1 ? a:2 : indent(lnum) + 1
  let synStack =  synstack(lnum, col)
  let inComment = 0
  for syn in synStack
    if synIDattr(synIDtrans(syn), "name") ==# 'Comment'
      let inComment = 1
    endif
  endfor
  return inComment
endfunction

" 2}}} ===================Delete Trailing White Space==================== {{{2

function! DeleteTrailingWS()
  execute "normal mz"
  %s/\s\+$//ge
  execute "normal `z"
endfunction

" 2}}} ==========================Switch Buffer=========================== {{{2

function! SwitchToBuf(filename)
  let fullfn = substitute(a:filename, "^\\~/", $HOME . "/", "")
  " find in current tab
  let bufwinnr = bufwinnr(a:filename)
  if bufwinnr != -1
    exec bufwinnr . "wincmd w"
    return
  else
    " find in each tab
    tabfirst
    let tab = 1
    while tab <= tabpagenr("$")
      let bufwinnr = bufwinnr(a:filename)
      if bufwinnr != -1
        exec "normal " . tab . "gt"
        exec bufwinnr . "wincmd w"
        return
      endif
      tabnext
      let tab = tab + 1
    endwhile
    " not exist, new tab
    exec "tabnew " . a:filename
  endif
 endfunction

" 2}}} ==============================Others============================== {{{2

function! s:SID_PREFIX()
  return matchstr(expand('<sfile>'), '<SNR>\d\+_')
endfunction

function! s:change_scratch_name(file)
  if a:file == ""
    let &titlestring = "[New]"
  else
    set titlestring=%t%(\ %M%)%(\ (%{expand(\"%:~:.:h\")})%)%(\ %a%)
  endif
endfunction

function! s:write_check_typo(file)
  let prompt = "possible typo: really want to write to '" . a:file . "'? (y/n):"
  if input(prompt) =~? '^\s*y'
    execute 'write' a:file
  endif
endfunction

function! s:grep(command, args)
  execute a:command '/'.a:args[-1].'/' join(a:args[:-2])
endfunction

function! XTermPasteBegin(ret)
  set paste
  return a:ret
endfunction

" 2}}}"

" 1}}}


" {{{1 ===========================FileType Specific===========================

" 2}}} ==============================ToHTML============================== {{{2

let g:html_no_progress = 0
let g:html_number_lines = 0
let g:html_use_css = 1
let g:html_ignore_conceal = 0
let g:html_pre_wrap = 0
let g:html_use_xhtml = 0

function! s:to_html()
endfunction

" 2}}} ============================JavaScript============================ {{{2

function! s:js_rc()
  let b:tc_option = ''
  let g:SimpleJsIndenter_BriefMode = 1
  setlocal iskeyword+=$
  setlocal iskeyword-=58
  setlocal cindent
endfunction

" 2}}} ===============================CSS================================ {{{2

function! s:css_rc()
  set foldmethod=marker
  setlocal iskeyword-=58
endfunction

" 2}}} ===============================SCSS=============================== {{{2

function! s:scss_rc()
  let b:tc_option = ''
  setlocal foldmethod=marker
  setlocal formatoptions=l2
endfunction

" 2}}} ===============================HAML=============================== {{{2

function! s:haml_rc()
  inoremap <LocalLeader>br <br><CR>
  let b:tc_option = ''
  setlocal iskeyword-=58
endfunction

" 2}}} ===============================HTML=============================== {{{2

function! s:html_rc()
  inoremap <LocalLeader>br <br><CR>
  inoremap <buffer> ;; <C-\><C-N>:call <SID>html_make_tag()<CR>
  inoremap <buffer> >> <C-\><C-N>:call <SID>html_close_tag()<CR>
  let html_no_rendering = 1
  let g:html_indent_inctags = "html,body,head,tbody"
  let g:event_handler_attributes_complete = 0
  let g:rdfa_attributes_complete = 0
  let g:microdata_attributes_complete = 0
  let g:atia_attributes_complete = 0
  if exists('g:xmldata_html5')
    let b:html_omni_flavor = 'html5'
  end
endfunction

function! s:html_make_tag()
  let save_reg = [getreg(), getregtype()]
  execute "normal! a \<C-\>\<C-N>db"
  let tag_name = @"
  call setreg(v:register, save_reg[0], save_reg[1])

  if tag_name =~ '\W'
    if tag_name == '>' && search('\%#\s*<', 'cnW', line('.'))
      execute "normal! cl" . tag_name . "\<C-\>\<C-N>a\<CR>"
      call feedkeys('O', 'n')
    else
      execute "normal! cl" . tag_name
      call feedkeys('a;;', 'n')
    endif
    return
  endif

  let unaryTagsStack = get(b:, 'unaryTagsStack', "area base br col command embed hr img input keygen link meta param source track wbr")
  if index(split(unaryTagsStack, '\s'), tag_name, 'ic') >= 0
    execute "normal! a<" . tag_name . ">"
    call feedkeys('a', 'n')
  else
    if getline('.') =~ '\S'
      execute "normal! cl<" . tag_name . "></" . tag_name . ">\<C-\>\<C-N>F>"
      call feedkeys('a', 'n')
    else
      execute "normal! cl<" . tag_name . ">\<CR></" . tag_name . ">\<C-\>\<C-N>O"
      call feedkeys('"_cc', 'n')
    endif
  endif
endfunction

function! s:html_close_tag()
  if search('\v(\<)|(\>)', 'bnpW') == 2
    let missing_gt = getline('.')[col('.')-1] == '>' ? '' : '>'
    execute "normal! a" . missing_gt . "</" . "\<C-X>\<C-O>" . "\<C-\>\<C-N>F<"
    call feedkeys('i', 'n')
  else
    call feedkeys('a>>', 'n')
  endif
endfunction

" 2}}} ===============================XML================================ {{{2

function! s:xml_rc()
  inoremap <buffer> ;; <C-\><C-N>:call <SID>html_make_tag()<CR>
  inoremap <buffer> >> <C-\><C-N>:call <SID>html_close_tag()<CR>
endfunction

" 2}}} ===============================Ruby=============================== {{{2

function! s:ruby_rc()
  let b:tc_option = ''
  setlocal cindent
  setlocal iskeyword-=58

  let g:rubycomplete_buffer_loading = 1
  let g:rubycomplete_classes_in_global = 1
  " let g:rubycomplete_rails = 1

  let g:ruby_operators = 0
  let g:ruby_space_errors = 1
  let g:ruby_no_expensive = 0
  let ruby_minlines = 70
endfunction

" 2}}} ===============================PHP================================ {{{2

function! s:php_rc()
  let php_asp_tags = 1
  let php_parent_error_close = 1
  let php_parent_error_open = 1
  setlocal iskeyword-=58 cindent
  set makeprg=php\ -l\ %
  set errorformat=%m\ in\ %f\ on\ line\ %l
endfunction

" 2}}} ===============================Help=============================== {{{2

function! s:help_rc()
  set number
  if version >= 703
    set conceallevel=1
    set concealcursor=nc
    set colorcolumn=+1
  endif

  nnoremap <silent> <buffer> <LocalLeader>= :call HelpHyperTextEntryJustify()<Enter>
endfunction

" 2}}} ===============================VIM================================ {{{2

function! s:vim_rc()
  let b:tc_option = ''
  " let g:vim_indent_cont = 0
  set path+=~/.vim/bundle
endfunction

" 2}}} ===============================ZSH================================ {{{2

function! s:zsh_rc()
  let b:tc_option = ''
  setlocal iskeyword-=-
endfunction

" 2}}} ============================Git Commit============================ {{{2

function! s:gitcommit_rc()
  setlocal textwidth=72
endfunction

" 2}}} ============================Git Config============================ {{{2

function! s:gitconfig_rc()
  let b:tc_option = ''
endfunction

" 2}}} ===========================Nginx Config=========================== {{{2

function! s:nginx_rc()
  let b:tc_option = ''
  setlocal iskeyword-=.
  setlocal iskeyword-=/
endfunction

" 2}}} ===========================YAML Config============================ {{{2

function! s:yaml_rc()
  let b:tc_option = ''
endfunction

" 2}}}

" 1}}}


" {{{1 =============================Auto-Commands=============================

augroup my_vimrc

  autocmd FileType * setlocal formatoptions=roql2

  autocmd FileType php,xml,html inoremap <buffer> <LocalLeader>/ </<C-X><C-O>

  " autocmd FileType ruby call s:ruby_rc()
  " autocmd FileType xml call s:xml_rc()
  " autocmd FileType html,xhtml,haml,eruby,phtml call s:html_rc()
  " autocmd FileType haml call s:haml_rc()
  " autocmd FileType php call s:php_rc()
  " autocmd FileType javascript call s:js_rc()
  " autocmd FileType css call s:css_rc()
  " autocmd FileType scss call s:scss_rc()
  autocmd FileType help call s:help_rc()
  autocmd FileType vim call s:vim_rc()
  " autocmd FileType zsh call s:zsh_rc()
  autocmd FileType gitcommit call s:gitcommit_rc()
  autocmd FileType gitconfig call s:gitconfig_rc()
  " autocmd FileType nginx call s:nginx_rc()
  " autocmd FileType yaml call s:yaml_rc()

  autocmd BufWrite *.h,*.c,*.cpp :call DeleteTrailingWS()

  autocmd FileType sh let g:is_bash=1
  autocmd FileType vim setlocal tabstop=2 softtabstop=2 shiftwidth=2 foldmethod=marker
  autocmd FileType c,cpp,java setlocal expandtab 
  " autocmd FileType rake,ruby,eruby,yaml setlocal tabstop=2 softtabstop=2 shiftwidth=2
  autocmd FileType qf setlocal modifiable statusline=%q\ %1*%<%-.{exists('w:quickfix_title')\ ?\ w:quickfix_title\ :\ ''}%0*
  if has("autocmd") && exists("+omnifunc")
    autocmd Filetype *
          \ if &l:omnifunc == "" |
          \ setlocal omnifunc=syntaxcomplete#Complete |
          \ endif
  endif

  " autocmd BufNewFile *.html  :0r ~/.vim/templates/html5.html
  " autocmd BufNewFile *.html  :0r ~/.vim/templates/html.html
  " autocmd BufNewFile *.css  :0r ~/.vim/templates/style.css
  " autocmd BufNewFile *.css  :0r ~/.vim/templates/css.css

  " autocmd BufRead www*.blogger.com*.txt setfiletype html
  " autocmd BufRead redmine.*.com*.txt setfiletype textile
  " autocmd BufRead pma.*com.*.txt setfiletype sql
  " autocmd BufRead /home/www/logs/*.log setfiletype httplog
  " autocmd BufRead /home/www/fc/log/*.log nnoremap <buffer> <LocalLeader>ddd :EmptyFile<CR>

  " autocmd BufNewFile,BufRead /bootleq/notes/*.txt set modeline
  " autocmd BufNewFile,BufRead /opt/nginx*/conf/*.conf,/opt/nginx*/conf/*.default setfiletype nginx

  autocmd CursorMovedI,InsertLeave * if pumvisible() == 0|silent! pclose|endif
  autocmd BufEnter * call s:change_scratch_name(expand('<afile>'))
  autocmd BufReadPost * if line("'\"") > 0 && line ("'\"") <= line("$") | execute "normal! g'\"" | endif
  autocmd BufWriteCmd *[,*],*'* call s:write_check_typo(expand('<afile>'))
  autocmd BufWinEnter * if exists('s:tabLineNeedRedraw') && s:tabLineNeedRedraw | redraw! | let s:tabLineNeedRedraw = 0 | endif
  " autocmd FileWritePost,BufWritePost *-\(debug\|src\).js :JsCompress! 1
  autocmd QuickFixCmdPost * redraw!
  autocmd QuickFixCmdPost * if len(getqflist()) > 0 | :QFix!<CR> | endif
  if has("gui_win32")
    autocmd GUIEnter * simalt ~x
  else
    autocmd GUIEnter * winpos 0 0 | redraw!
  endif
  " autocmd WinLeave * setlocal nocursorline
  " autocmd WinEnter,BufRead * setlocal cursorline

  " let apache_version = "2.0"
  " let dosbatch_cmdextversion = 2

augroup END

" 1}}}


" {{{1 ================================Finish=================================
set secure

" vim: expandtab softtabstop=2 shiftwidth=2 foldmethod=marker
